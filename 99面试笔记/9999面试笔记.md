





# 面试题



\### 6.组件传值分为（父传子、子传父、兄弟组件之间传值）
\### 7.keep-alive是怎么使用的
缓存、会多出来几个生命周期



css
\1. 一个盒子垂直水平居中有哪些方法

https://www.cnblogs.com/gzy-tw/p/11205854.html

\2. flex:1 是什么意思

https://www.runoob.com/cssref/css3-pr-flex.html

\3. rem为什么可以实现自适应布局

https://blog.csdn.net/qq_42707446/article/details/93200711

> em：基于父级元素的字体大小；
>
> rem：基于html的字体大小
>
> 由于浏览器的字体大小一般默认是16px；1rem=16px;

http
\1. 三次握手和四次挥手

https://www.pianshen.com/article/8384298792/

\2. 常见状态码

301和302的区别 https://blog.csdn.net/banana960531/article/details/85621865

\3. http的8种请求方式及区别

Vue
\1. axios底层是怎么实现的

https://blog.csdn.net/luchuanqi67/article/details/81329358 https://www.jianshu.com/p/8bc48f8fde75

\2. Vue的生命周期

created和mounted的区别

https://cn.vuejs.org/v2/guide/instance.html

\4. keep-alive的作用

https://www.jianshu.com/p/9523bb439950

\5. Vue的双向绑定原理

https://www.jianshu.com/p/78b31df97b70





# 前端归纳总结

1. typeof 能够判断哪些类型？
2. == 和 === 有什么区别？
3. window.onload 和 DOMContentLoaded 的区别？
4. 创建10个<a>标签， 点击的时候弹出相应的序号
5. 手写字节流throttle、防抖debounce
6. Promise解决了什么问题



解答：

1. typeof 运算符返回一个用来表示表达式的数据类型的字符串。 
   可能的字符串有："number"、"string"、"boolean"、"object"、"function" 和 "undefined"。 常用返回值说明

| 表达式                 | 返回值      |
| ---------------------- | ----------- |
| typeof undefined       | 'undefined' |
| typeof null            | 'object'    |
| typeof true            | 'boolean'   |
| typeof 123             | 'number'    |
| typeof "abc"           | 'string'    |
| typeof function() {}   | 'function'  |
| typeof {}              | 'object'    |
| typeof []              | 'object'    |
| typeof unknownVariable | 'undefined' |

### HTML

#### 1、何如理解HTML标签语义化？

> 让人更加容易读懂
>
> 让搜索引擎更容易读懂



#### 2、块级元素，行内标签，行内块元素，区别

```
块级标签：<h1>~<h6>、<p>、<div>、<ul>、<ol>、<li>

行内元素：<a>、<strong>、<b>、<em>、<i>、<del>、<s>、<ins>、<u>、<span>

行内块元素：<img />、<input />、<td>
```

区别：

	区别主要是三个方面:一是排列方式，二是宽高边距设置，三是默认宽度。

(1)块级元素会独占一行，而内联元素和内联块元素则会在一行内显示。

(2)块级元素和内联块元素可以设置 width、height 属性，而内联元素设置无效。

(3)块级元素的 width 默认为 100%，而内联元素则是根据其自身的内容或子元素来决定其宽度。


#### 3、浏览器内核

```
Trident：这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多
网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微
软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等
安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。

Gecko：这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩
展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。

Presto：Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的
天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。

Webkit：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trid
ent，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 
前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。

Blink：谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 B
link 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是
KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 
内核，加入 Google 阵营，跟随谷歌一起研发 Blink。
```

因为浏览器太多啦， 但是现在主要流行的就是下面几个：

| 浏览器  |      内核      | 备注                                                         |
| :------ | :------------: | :----------------------------------------------------------- |
| IE      |    Trident     | IE、猎豹安全、360极速浏览器、百度浏览器                      |
| firefox |     Gecko      | 可惜这几年已经没落了，打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。 |
| Safari  |     webkit     | 现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了）。苹果感觉像被别人抢了媳妇，都哭晕再厕所里面了。 |
| chrome  | Chromium/Blink | 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用Blink内核。二次开发 |
| Opera   |     blink      | 现在跟随chrome用blink内核。                                  |

**拓展阅读：**

```
移动端的浏览器内核主要说的是系统内置浏览器的内核。

Android手机而言，使用率最高的就是Webkit内核，大部分国产浏览器宣称的自己的内核，基本上也是属于webkit二次开发。

iOS以及WP7平台上，由于系统原因，系统大部分自带浏览器内核，一般是Safari或者IE内核Trident的
```



####  4、async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）

```
（1）脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执
     行。

 （2）defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。
     当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。

 （3）async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执
     行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。
```

![](D:\Document\00_Notes\000前端笔记\99面试笔记\media\js、html执行顺序.png)

#### 5、html,css,js加载顺序

```html
<head lang="en">
    <meta charset="utf-8">
    <title></title>
    <link rel="stylesheet" href="css/*.css">
    <script src="js/*.js></script>
</head>
```

```
DOM文档的加载顺序是由上而下的顺序加载；

1、DOM加载到link标签
	css文件的加载是与DOM的加载并行的，也就是说，css在加载时Dom还在继续加载构建，而过程中遇到的css样式或者img，则会向服务器发送一个请求，待资源返回后，将其添加到dom中的相对应位置中；

2、DOM加载到script标签
	由于js文件不会与DOM并行加载，因此需要等待js整个文件加载完之后才能继续DOM的加载，倘若js脚本文件过大，则可能导致浏览器页面显示滞后，出现“假死”状态，这种效应称之为“阻塞效应”；会导致出现非常不好的用户体验；
而这个特性也是为什么在js文件中开头需要$(document).ready(function(){})或者（function(){}）或者window.onload,即是让DOM文档加载完成之后才执行js文件，这样才不会出现查找不到DOM节点等问题；

js阻塞其他资源的加载的原因是：浏览器为了防止js修改DOM树，需要重新构建DOM树的情况出现

3、解决方法
前提，js是外部脚本；

在script标签中添加 defer=“ture”，则会让js与DOM并行加载，待页面加载完成后再执行js文件，这样则不存在阻塞；

在scirpt标签中添加 async=“ture”，这个属性告诉浏览器该js文件是异步加载执行的，也就是不依赖于其他js和css，也就是说无法保证js文件的加载顺序，但是同样有与DOM并行加载的效果；

同时使用defer和async属性时，defer属性会失效；

可以将scirpt标签放在body标签之后，这样就不会出现加载的冲突了。
```



[html,css,js加载顺序](https://www.cnblogs.com/yingsong/p/6170780.html)

```
html,css,js加载顺序

1.js放在head中会立即执行，阻塞后续的资源下载与执行。因为js有可能会修改dom，如果不阻塞后续的资源下载，dom的操作顺序不可控。正常的网页加载流程是这样的。
1、浏览器一边下载HTML网页，一边开始解析
2、解析过程中，发现<script>标签
3、暂停解析，网页渲染的控制权转交给JavaScript引擎
4、如果<script>标签引用了外部脚本，就下载该脚本，否则就直接执行
5、执行完毕，控制权交还渲染引擎，恢复往下解析HTML网页
　　如果外部脚本加载时间很长（比如一直无法完成下载），就会造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。html需要等head中所有的js和css加载完成后才会开始绘制，但是html不需要等待放在body最后的js下载执行就会开始绘制,因此将js放在body的最后面，可以避免资源阻塞，同时使静态的html页面迅速显示。将脚本文件都放在网页尾部加载，还有一个好处。在DOM结构生成之前就调用DOM，JavaScript会报错，如果脚本都在网页尾部加载，就不存在这个问题，因为这时DOM肯定已经生成了。


2.js的执行依赖前面的样式。即只有前面的样式全部下载完成后才会执行js，但是此时外链css和外链js是并行下载的。
　　css需要分块，首页的css独立，其余的css需要动态加载，因为html的绘制会被css阻塞，这样可以减少首次进入时的白屏时间。

3.外链的js如果含有defer="true"属性，将会并行加载js，到页面全部加载完成后才会执行，会按顺序执行。
　　defer属性的作用是，告诉浏览器，等到DOM加载完成后，再执行指定脚本。

    1、浏览器开始解析HTML网页
    2、解析过程中，发现带有defer属性的script标签
    3、浏览器继续往下解析HTML网页，同时并行下载script标签中的外部脚本
    4、浏览器完成解析HTML网页，此时再执行下载的脚本
      对于内置而不是连接外部脚本的script标签，以及动态生成的script标签，defer属性不起作用。
 

4.外链的js如果含有async="true"属性，将不会依赖于任何js和css的执行，此js下载完成后立刻执行，不保证按照书写的顺序执行。因为async="true"属性会告诉浏览器，js不会修改dom和样式，故不必依赖其它的js和css。　

　　async属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。

1、浏览器开始解析HTML网页
2、解析过程中，发现带有async属性的script标签
3、浏览器继续往下解析HTML网页，同时并行下载script标签中的外部脚本
4、脚本下载完成，浏览器暂停解析HTML网页，开始执行下载的脚本
5、脚本执行完毕，浏览器恢复解析HTML网页
　　async属性可以保证脚本下载的同时，浏览器继续渲染。需要注意的是，一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。另外，使用async属性的脚本文件中，不应该使用document.write方法。

　　一般来说，如果脚本之间没有依赖关系，就使用async属性，如果脚本之间有依赖关系，就使用defer属性。如果同时使用async和defer属性，后者不起作用，浏览器行为由async属性决定。
```

#### 6、什么是重绘和回流？

```
重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background
       -color，我们将这样的操作称为重绘。
 
 回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样
      的操作我们称为回流。

 常见引起回流属性和方法：

 任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。

 （1）添加或者删除可见的 DOM 元素；
 （2）元素尺寸改变——边距、填充、边框、宽度和高度
 （3）内容变化，比如用户在 input 框中输入文字
 （4）浏览器窗口尺寸改变——resize事件发生时
 （5）计算 offsetWidth 和 offsetHeight 属性
 （6）设置 style 属性的值
 （7）当你修改网页的默认字体时。

 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列
 回流。
```



#### 7、浏览器渲染流程

```
CSS：
CSS 放在 head 中会阻塞页面的渲染（页面的渲染会等到 css 加载完成）
	 CSS 加载不会阻塞 DOM 的解析，CSS 加载会阻塞 Dom 的渲染。
CSS 阻塞 JS 的执行 （因为 GUI 线程和 JS 线程是互斥的，因为有可能 JS 会操作 CSS）
CSS 不阻塞外部脚本的加载（不阻塞 JS 的加载，但阻塞 JS 的执行，因为浏览器都会有预先扫描器）


JS：
直接引入的 JS 会阻塞页面的渲染（GUI 线程和 JS 线程互斥）
异步加载的 JS （script 标签中添加 defer 属性）不阻塞页面的解析
异步加载的 JS （script 标签中添加 async 属性）下载过程不阻塞页面的解析，下载完成后立即执行，执行过程会阻塞页面的解析
JS 不阻塞资源的加载
JS 顺序执行，阻塞后续 JS 逻辑的执行
```

[掘金](https://juejin.cn/post/6844903815091748872)

写的很好~

[掘金-你不知道的浏览器页面渲染机制](https://juejin.cn/post/6844903815758479374)

★★★★★ [从 8 道面试题看浏览器渲染过程与性能优化](https://juejin.cn/post/6844904040346681358)

>  为什么 JS 阻塞页面加载 ? 
> 由于 JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了。
> 因此为了防止渲染出现不可预期的结果,浏览器设置 **GUI 渲染线程与 JavaScript 引擎为互斥的关**系。
> 当 JavaScript 引擎执行时 GUI 线程会被挂起,GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。
> 从上面我们可以推理出,由于 GUI 渲染线程与 JavaScript 执行线程是互斥的关系,
> 当浏览器在执行 JavaScript 程序的时候,GUI 渲染线程会被保存在一个队列中,直到 JS 程序执行完成,才会接着执行。
> 因此如果 JS 执行的时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞的感觉。
>
> 
>
> css 加载会造成阻塞吗 ？ 
> 由上面浏览器渲染流程我们可以看出 :
> DOM 和 CSSOM 通常是并行构建的,所以 CSS 加载**不会阻塞** DOM 的**解析**。
> 然而,由于 Render Tree 是依赖于 DOM Tree 和 CSSOM Tree 的,
> 所以他必须等待到 CSSOM Tree 构建完成,也就是 CSS 资源加载完成(或者 CSS 资源加载失败)后,才能开始渲染。
> 因此,CSS 加载**会阻塞** Dom 的**渲染**。
> 由于 JavaScript 是可操纵 DOM 和 css 样式 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了。
> 因此为了防止渲染出现不可预期的结果,浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系。
> 因此,样式表会在后面的 js 执行前先加载执行完毕,所以**css 会阻塞后面 js 的执行**。



### CSS

#### 一、布局

##### 盒子模型

```
标准盒与怪异盒的区别在于他们的总宽度的计算公式不一样。

标准模式下总宽度offsiteWith=width+margin（左右）+padding（左右）border（左右）；怪异模式下总宽度width+margin（左右）（就是说width已经包含了padding和border值）。

标准模式下如果定义的DOCTYPE缺失，则在ie6、ie7、ie8下汇触发怪异模式。

当设置为box-sizing:content-box时，将采用标准模式解析计算，也是默认模式；

当设置为box-sizing:border-box时，将采用怪异模式解析计算；
```



##### margin纵向重叠

```
1.相邻块元素垂直外边距的合并

2.嵌套块元素垂直外边距的合并（塌陷）(想要让子盒子再父盒子中往下移动一些)



1.相邻元素的margin-top 和 margin-bottom 会发生重叠

2.空白内容的<p></p>标签也会发生重叠。
```



##### margin负值

```
margin-top（上） margin-left（左） 设置负值，元素会向上、左移动

margin-right（右） 设置负值，右侧元素左移，自身不受影响

margin-bottom（下） 设置负值，下方元素上移，自身元素不受影响
```



##### BFC

> BFC block format context，块级格式化上下文
>
> 一块独立的渲染区域，内部元素的渲染不会影响到边界以外的元素

创建BFC的方式

```
* float 属性不为 none
* position 为 absolute 或者 fixed
* display 为 inline-block、table-cell、flex
* overflow 为hidden、auto、scroll
```



##### 显示与隐藏总结：

| 属性           | 区别                   | 用途                                                         |
| -------------- | ---------------------- | ------------------------------------------------------------ |
| **display**    | 隐藏对象，不保留位置   | 配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 |
| **visibility** | 隐藏对象，保留位置     | 使用较少                                                     |
| **overflow**   | 只是隐藏超出大小的部分 | 1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围      |

[你可能不知道的CSS隐藏页面元素的方法(8种及其区别)](https://juejin.cn/post/6844903860771749895)

[display和visibility的区别是什么？](https://www.html.cn/qa/css3/13399.html)

```
display和visibility的区别

一、空间占据

display: none; 是彻底消失，不在文档流中占位，浏览器也不会解析该元素

visibility:hidden; 是视觉上消失了，可以理解为透明度为0的效果，在文档流中占位，浏览器会解析该元素；

******************************************************************************************
使用visibility:hidden比display:none性能上要好，display:none切换显示时，页面产生回流（当页面中的一部分元素需要改变规模尺寸、布局、显示隐藏等，页面重新构建，此时就是回流。所有页面第一次加载时需要产生一次回流），而visibility切换是否显示时则不会引起回流。
******************************************************************************************

二、子元素继承

display:none 不会被子元素继承，但是父元素都不在了，子元素自然也就不会显示了，皮之不存，毛之安附~~

visibility:hidden 会被子元素继承，可以通过设置子元素visibility:visible 使子元素显示出来

opacity: 0 也会被子元素继承，但是不能通过设置子元素opacity: 0使其重新显示

三、事件绑定

display:none 的元素都已经不再页面存在了，因此肯定也无法触发它上面绑定的事件；

visibility:hidden 元素上绑定的事件也无法触发；

opacity: 0元素上面绑定的事件是可以触发的。

四、过渡动画

transition对于display 肯定是无效的；

transition对于visibility 也是无效的；

transition对于opacity 是有效。
```



BFC能够结局什么问题

> 1、边距重叠问题

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    * {
        margin: 0;
        padding: 0;
    }
    
    div {
        width: 100px;
        height: 100px;
        background-color: skyblue;
    }
    
    .top {
        margin-bottom: 20px;
    }
    
    .bottom {
        margin-top: 20px;
    }
    
    p {
        overflow: hidden;
    }
</style>

<body>
    <div class="top"></div>
    <p>
        <div class="bottom"></div>
    </p>
</body>

</html>
```

> 2、盒子塌陷问题

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    * {
        margin: 0;
        padding: 0;
    }
    
    .father {
        width: 200px;
        height: 200px;
        background-color: skyblue;
        overflow: hidden;
    }
    
    .son {
        width: 100px;
        height: 100px;
        background-color: gold;
        margin-top: 50px;
    }
</style>

<body>
    <div class="father">
        <div class="son"></div>
    </div>
</body>

</html>
```

> 3、清除浮动

> 4、清除浮动环绕文字



##### 圣杯布局 双飞翼布局

> [圣杯布局和双飞翼布局的理解与思考](https://www.jianshu.com/p/81ef7e7094e8)

##### 清除浮动

**清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了**



> 1、额外标签法(隔墙法)
>
> ```
> 是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 <div style=”clear:both”></div>，或则其他标签br等亦可。
> ```
>
> 
>
> 2、父级添加overflow属性方法
>
> ```
> 可以给父级添加： overflow为 hidden| auto| scroll  都可以实现。
> ```
>
> 
>
> 3、**:after 方式为空元素额外标签法的升级版，好处是不用单独加标签了** 
>
> ```
> .clearfix:after {  content: ""; display: block; height: 0; clear: both; visibility: hidden;  }   
> 
> .clearfix {*zoom: 1;}   /* IE6、7 专有 */
> ```
>
> 
>
> 4、使用双伪元素清除浮动
>
> ```
> .clearfix:before,.clearfix:after { 
> content:"";
> display:table; 
> }
> .clearfix:after {
> clear:both;
> }
> .clearfix {
> *zoom:1;
> }
> ```

##### flex布局

> 设置主轴：flex-direction:row / column
>
> 设置主轴上的子元素排列方式：justify-content: space-around / space-between
>
> 设置是否换行：flex-wrap: wrap / no-wrap
>
> 侧轴上的子元素排列方式（单行 ）：align-items: flex-start
>
> 侧轴上的子元素的排列方式（多行）：align-content: centent
>
> 控制子项自己在侧轴上的排列方式：align-self控制子项自己在侧轴上的排列方式



##### flex属性

1. 简单介绍flex布局
   flex布局则是一种布局方案，设置父div的css属性display:flex，即可实现flex布局。该父div即为容器，而其内的子元素（如子div）称为项目。
   容器和项目各自有不同的css属性，以实现不同的布局效果，
   其中容器的主要属性有flex-direction、flex-wrap、flex-flow（前两个属性缩写）、justify-content、align-items等，这里不做展开。
   项目的主要属性有order、flex-grow、flex-shrink、flex-basis、flex、align-self等，其中flex为flex-grow、flex-shrink、flex-basis三个属性的缩写。
   2.flex-grow、flex-shrink、flex-basis属性介绍
   `flex-grow`：定义项目的的放大比例；**默认为0，即使存在剩余空间，也不会放大；**为1时，等分剩余空间，自动放大占位；为n时， 占据的空间（放大的比例）是flex-grow为1的n倍。
   `flex-shrink`：定义项目的缩小比例；**默认为1，即如果空间不足，该项目将缩小，且缩小比例相同**；为0时，空间不足该项目也不会缩小；为n时，空间不足缩小的比例是flex-shrink为1的n倍。
   `flex-basis`： 定义在分配多余空间之前，项目占据的主轴空间，**默认值为auto，即项目原本大小**；设置后项目将占据固定空间。
2. flex:1属性介绍
   flex为flex-grow、flex-shrink、flex-basis三个属性的缩写。
   flex属性默认值为：**0 1 auto （不放大会缩小）**，常用属性值有none：0 0 auto （不放大也不缩小）、auto：**1 1 auto （放大且缩小）**。
   flex：n（非负数字）代表 flex-grow：n；flex-shrink：1；flex-basis：0%；
   flex：n1，n2（两个非负数字）代表flex-grow：n1；flex-shrink：n2； flex-basis：0%；
   flex：L（长度或百分比）代表 flex-grow：1；flex-shrink：1；flex-basis：L；
   flex：n，L（一个非负数字、一个长度或百分比）代表flex-grow：n；flex-shrink：1；flex-basis：L;
   总结：flex-grow和flex-shrink在flex属性中不规定值时则为1，flex-basis为0%。所以flex：1即为flex-grow：1；flex-shrink：1；flex-basis：0%；经常用作自适应布局，内容区会自动放大占满剩余空间。

![](D:\Document\00_Notes\000前端笔记\99面试笔记\media\flex-basis.png)









##### 水平垂直居中

[https://www.cnblogs.com/gzy-tw/p/11205854.html](https://www.cnblogs.com/gzy-tw/p/11205854.html)

1、定位，子绝父相，transform:translate(-50%,-50%);

2、定位，子绝父相，上下左右设置0，margin:auto;

3、利用display：flex;设置垂直水平都居中；

```css
.parent{
    display:flex;
    justify-content:center;
    align-items:center;
}
```

4、利用display:table-cell;

```css
.parent{
    display:table-cell;
    vertical-align:middle;
    text-align:center;
}
.child{
	display:inline-block;
}
```





#### 二、定位

##### absolute 和 relative 分别依据是什么

> 绝对定位：不占位置，脱标，父亲没有定位，以浏览器进行定位；
>
> 相对定位：占据位置，占据位置



区别：

relation ***相对定位***，相**对于自己**的文档流的位置定位，不会脱离文档流

absolute ***绝对定位***，相对于具有relative、absolute、fixed、sticky 的最近的父容器来定位，会脱离文档流

fixed  **固定定位**，只认**浏览器的可视窗口** —— `浏览器可视窗口 + 边偏移属性` 来设置元素的位置，会脱离文档流

static **静态定位**



##### 居中对齐

> 水平居中：
>
> > inline 元素：text-align: center
> >
> > block元素： margin: auto
> >
> > absolute元素：left:50% + margin-left负值(宽度一半)
>
> 垂直居中：
>
> > inline 元素：line-heigt = 行高， vertical-align 垂直对齐
> >
> > block元素： 
> >
> > absolute元素：top:50% + margin-top负值
> >
> > absolute元素：left：50%，top：50%；transform(-50%, -50%)
> >
> > absolute元素：top,left,bottom,right = 0 + margin: auto

#### 三、图文样式

* **line-heighe继承问题**

  > 如果行高是百分数，那么先计算再继承。

#### 四、响应式

* **rem em px 对比**

  > px：绝对长度单位
  >
  > em：相对长度单位，相对于父元素
  >
  > rem：相对长度单位，相对于根元素

* **如何实现响应式**

  > media-query，根据不同屏幕宽度设置根元素font-size
  >
  > rem

* **rem的局限性**

  > rem 具有台阶性
  >
  > vh 网页视口高度1/100；vw网页视口宽度：1/100； 

* 继承

  > 

#### 五、CSS3动画

#### 六、选择器权重

```
!importent ---------------- infinity
行间样式 ------------------- 1000
id选择器 ------------------------ 100
class类选择器 | 属性选择器 | 伪类 --------- 10
标签选择器 | 伪元素 --------------- 1
通配符 ---------------------- 0
```

> CSS2 中伪类、伪元素都是以单冒号`:`表示
>
> CSS2.1 后规定伪类用单冒号：表示，伪元素用双冒号`::`表示，浏览器同样接受 CSS2 时代已经存在的伪元素(:before, :after, :first-line, :first-letter 等)的单冒号写法。对于 CSS2 之后所有新增的伪元素(如::selection)，应该采用双冒号的写法。但是因为兼容性问题，大部分还是用的单冒号。



#### 七、伪类和伪元素

```
伪类的概念
1. 规范解释
伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。
2. 举例说明
当用户悬停在指定的元素时，我们可以通过 :hover 来描述这个元素的状态。虽然它和普通的 CSS 类相似，可以为已有的元素添加样式，但是它只有处于 DOM 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。

伪元素的概念
1. 规范解释
伪元素用于创建一些不在文档树中的元素，并为其添加样式。
2. 举例说明
我们可以通过 :before 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。
```

区别：

1、**伪类**是操作文档中**已有的元素**，而**伪元素**是创建了一个**文档外的元素**，两者最关键的区别就是这点。

2、伪类，首先是类的一种， 作用于标签本身（状态），伪元素首先是元素，作用于内容本身。

- `CSS` 伪类用于向某些选择器添加特殊的效果。
- `CSS` 伪元素用于将特殊的效果添加到某些选择器。

3、伪类只能使用“：”，而伪元素既可以使用“:”，也可以使用“::”





>  伪类
>
>  * 状态：
>   * :link
>   * :visited
>   * :hover
>   * activate
>   * :foucs
>  * 结构化：
>   * :first-child
>   * :last-child
>   * :nth-child
>   * :nth-of-type

> 伪元素
>
> * 单双冒号
>   * ::before / :before
>   * ::after / :after
>   * :: first-letter / :first-letter
>   * :: first-line / :first-line
> * 仅双冒号
>   * ::selection
>   * ::placeholder
>   * ::backdrop

```
::before 匹配在原始元素的实际内容之后出现的区域  

::after 匹配在原始元素的实际内容之前出现的区域 

::first-letter 匹配元素的第一个字母 

::first-line 匹配元素第一行 

::selection 匹配被选中的文本或者区域


```



### JavaScript

#### 一、基础部分

##### 1、typeof 

1. typeof 可以判断那些类型？

   * typeof 返回值有六种可能： **"number," "string," "boolean," "object," "function,"** 和 "**undefined**."以及'**symbol**'
   * **null,array,object**返回的都是**‘object’**

   > 1. 识别出所有的值类型
   >
   >    ```js
   >    // typeof 能判断所有的值类型
   >    let a;                console.log(typeof a) // undefined
   >    const a = 'string'    console.log(typeof a) // string
   >    const a = 1           console.log(typeof a) // number
   >    const a = true        console.log(typeof a) // boolean
   >    const a = Symbol('a') console.log(typeof a) // Symbol
   >    ```
   >
   > 2. 可以判断出函数（function）
   >
   >    ```js
   >    // typeof 能判断函数
   >    typeof console.log(1)    // function
   >    typeof function fn () {} // function
   >    ```
   >
   > 3. 判断是否是引用类型（不可再细分，只要是就是object）(null 是一个特殊的引用数据类型)
   >
   >    ```js
   >    // typeof 判断引用类型
   >    const a = null       typeof a //object
   >    const a = { a: 100 } typeof a // object
   >    const a = ['a']      typeof a // object
   >    ```

   > 注意！typeof（未定义变量）的结果是 undefined。



#####  2、“===” 与  "=="

何时使用 == 何时使用 === 

```js
"==="叫做严格运算符，"=="叫做相等运算符。

严格运算符的运算规则如下:
(1)不同类型值
如果两个值的类型不同，直接返回false。
(2)同一类的原始类型值
同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。
(3)同一类的复合类型值
两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。
(4)undefined和null（他们与自身严格相等）
/*******************************************************/
null === null // true	
undefined === undefined // true
null === undefined	// false
/*******************************************************/
相等运算符的运算规则如下:
	相等运算符在比较相同类型的数据时，与严格相等运算符完全一样。在比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。类型转换规则如下：
(1)原始类型的值
原始类型的数据会转换成数值类型再进行比较。字符串和布尔值都会转换成数值。
(2)对象与原始类型值比较
对象（这里指广义的对象，包括数值和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行
比较。
(3)undefined和null
	undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。
/*******************************************************/
    null == null // true	
	undefined == undefined // true
	null == undefined	// true
/*******************************************************/
(4)相等运算符的缺点
相等运算符隐藏的类型转换，会带来一些违反直觉的结果。
    '' == '0' // false
    0 == '' // true
    0 == '0' // true
    false == 'false' // false
    false == '0' // true
    false == undefined // false
    false == null // false
    null == undefined // true
    ' \t\r\n ' == 0 // true
/*******************************************************/
	NaN == NaN      // false，NaN和所有值包括自己都不相等。
/*******************************************************/
这就是为什么建议尽量不要使用相等运算符。至于使用相等运算符会不会对后续代码造成意外影响，答案是有可能会。
 var a = undefined;
        if (!a) {
            console.log("1"); //1
        }
        var a = undefined;
        if (a == null) {
            console.log("1"); //1
        }
        var a = undefined;
        if (a === null) {
            console.log("1"); //无输出
        }
也就是说当a为undefined时，输出的值会有变化，而在编程中对象变成undefined实在是太常见了。
```

> **总结**
>
> 除了 == null 之外，其他都一律用 === 
>
> ```js
> const obj = {x : 100};
> if (obj.a == null) {}
> // 相当于；
> // if （obj.a === null || obj.a === undefined）{}
> ```
>



#####  3、null 和 undefined

```
首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。

undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null
主要用于赋值给一些可能会返回对象的变量，作为初始化。

undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它
会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。

当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等
号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。
```



值类型和引用类型的区别

引用类型赋值、手写深拷贝

> 常见引用数据类型：{x:100}; arr = [] ;const n = null; function fn() {}
>
> null 是一个特殊的引用类型，指针指向为空地址
>
> 函数是一个特殊的引用类型，但是不用于存储地址，所以没有拷贝、复制函数之说

将引用类型赋值的时候，传递的是引用类型的地址字符串拼接

```js
const a = 100 + 10;		// 110
const b = 100 + '10';	// '10010'
const c = true + '10';	// 'true10'
```



falsely 变量和 truely 变量，if条件判断中的是这个，而不是true 和 false



##### 4、for in 与 深拷贝

* for in 和 for of

区别一：

> for in遍历的是数组的索引（即键名）
>
> 而for of遍历的是数组元素值。



区别二：

> for in会遍历数组所有的可枚举属性，包括原型
>
> for of 不能遍历对象



区别三：

for in (以及forEach for) 是常规的同步遍历

```js
for(let i in this.book) {
	this.book[i]
}
```

for of 常用于异步的遍历

```js
for(let book of this.book) {
    
}
```

```js
function deepClone(obj = {}) {
    if (typeof obj !== 'object' || typeof obj == null) {
        // obj 是 null 类型，或者不是对象也不是数组（即简单数据类型）
        return obj;
    }
    let result
    if (obj instanceof Array) {
        // 是数组
        result = []
    } else {
        // 不是数组
        result = {}
    }
    // 上面也可以使用三元表达式去表示
    // result = obj instanceof Array ? [] : {}

    for (const key in obj) {
        // 保证 key 不是原型链的属性
        if (obj.hasOwnProperty(key)) {
            // 递归
            result[key] = deepClone(obj[key])
        }
    }

    return result
}
```





#### 二、原型和原型链

##### 1、instanceof

```js
// instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。

function instanceOf(left,right) {
    let proto = left.__proto__;
    let prototype = right.prototype
    while(true) {
        if(proto === null) return false
        if(proto === prototype) return true
        proto = proto.__proto__;
    }
}
```

##### 2、原型链

任何对象都有原型对象,也就是prototype属性,任何原型对象也是一个对象,该对象就有__proto__属性,这样一层一层往上找,就形成了一条链,我们称此为原型链;

```
当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。
如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。
如果还没有就查找原型对象的原型（Object的原型对象）。
依此类推一直找到 Object 为止（null）。
__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。
```



​	每一个实例对象又有一个__proto__属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有__proto__属性，这样一层一层往上找就形成了原型链。

![](.\media\原型链.png)

```
1.构造函数的prototype属性指向了构造函数原型对象
2.实例对象是由构造函数创建的,实例对象的__proto__属性指向了构造函数的原型对象
3.构造函数的原型对象的constructor属性指向了构造函数,实例对象的原型的constructor属性也指向了构造函数
```

![img4](.\media\原型链-2.png)

##### 3、继承

![](.\media\预备知识1.png)



![](.\media\预备知识2.png)



![](.\media\方式1-概述.png)



![](.\media\方式1-实现.png)



![](./\media\方式2-概述.png)



![](.\media\方式2-实现.png)



![](.\media\方式3-概述.png)



![](.\media\方式3-实现.png)



![](.\media\方式4-概述.png)



![](.\media\方式4-实现.png)



![](.\media\方式5.png)



5.  Class继承

> 说明：ES6新增，class是一个语法糖，就是基于寄生组合继承来实现的；

 

说明

**object.create()**

[Object.create()、new Object()和{}的区别](https://juejin.cn/post/6844903917835436045)

```js
Object.create(proto,[propertiesObject])
// 第一个对象必选:新创建对象的原型对象
// 第二个对象可选:要添加到新对象的可枚举（新添加的属性是其自身的属性，而不是其原型链上的属性）的属性。
```

object.create() 和 new 的区别？	其实就是创建出来的实例，实例的原型(`__proto__`)指向不同

字面量和`new`关键字创建的对象是`Object`的实例，原型指向`Object.prototype`，继承内置对象`Object`

`Object.create(arg, pro)`创建的对象的原型取决于`arg`，`arg`为`null`，新对象是空对象，没有原型，不继承任何对象；`arg`为指定对象，新对象的原型指向指定对象，继承指定对象





#### 三、作用域和闭包

* 全局作用域：

​		全局作用域只有一个全局对象 window，创建的对象都会作为window对象的属性保存；创建的函数都做作为 window 对象的方法进行保存。

1. 函数声明和变量声明提前，但是，函数表达式不会提前！

2. 相同的函数名和var声明的变量，函数名具有更高的优先级。

```js
a = 5； ==> window.a = 5;
```

```js
// 情况一
console.log(a);		// undefined
var a = 123;

// 情况二
console.log(a);		// 报错
a = 123;
```

```js
fn()	// fn() 函数执行

function fn() {
    console.log("fn() 函数执行")
}

var fn2 = function() {
    console.log("fn() 函数执行")
}
```

```js
console.log(fn2)	// undefined
fn2()				// 报错！undefined is not a function

function fn() {
    console.log("fn() 函数执行")
}

var fn2 = function() {
    console.log("fn() 函数执行")
}
```



##### 1、手写new

```js
// （1）首先创建了一个新的空对象
// （2）设置原型，将对象的原型设置为函数的 prototype 对象。
// （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
// （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。
```

(1) 创建一个新对象；
(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） ；
(3) 执行构造函数中的代码（为这个新对象添加属性）;
(4) 返回新对象。

```js
function Dog(name){
    this.name = name
}
Dog.prototype.sayName = function(){
    console.log(this.name)
}
// 上面是本身Dog
function _new(fn,...args){   // ...args为ES6展开符,也可以使用arguments
    //先用Object创建一个空的对象,
    const obj = Object.create(fn.prototype)  //fn.prototype代表 用当前对象的原型去创建
    //现在obj就代表Dog了,但是参数和this指向没有修改
    const rel = fn.apply(obj,args)
    //正常规定,如何fn返回的是null或undefined(也就是不返回内容),我们返回的是obj,否则返回rel
    return rel instanceof Object ? rel : obj
}
var _newDog = _new(Dog,'这是用_new出来的小狗')
_newDog.sayName()
```



##### 2、this、call、apply、bind区别

**this 永远指向最后调用它的那个对象**。箭头函数的 this 始终指向**函数定义时的 this**，而非执行时。箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined。

`call`：所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。

`apply`语法：**fun.apply(thisArg, [argsArray])**

​			apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。

`bind `是创建一个新的函数，我们必须要手动去调用。

注意：`某个函数的参数是明确知道数量时用 call ; 而不确定的时候用 apply，然后把参数 push进数组传递进去`。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来遍历所有的参数



##### 3、this在不同场景下如何取值？

所以我们对其四个规则进行排序：**new绑定>显式绑定>隐式绑定>默认绑定**

同时我们可以得出一套规律：

1. 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。`var bar = new foo()`
2. 函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。`var bar = foo.call(obj2)`
3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。`var demo2= obj.foo()`
4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。`demo();`



**小结**

如果要判断一个运行中的this绑定，重中之重就是找到它的**调用位置**，找到之后根据下面四条规则来判断this指针的绑定对象。

1.  是否由new声明绑定到指定对象。
2.  是否由call、apply或者bind调用。
3.  是否上下文调用
4.  默认绑定，在严格模式下为undefined，否则绑定到全局对象。

​    同时要注意有时候会触发绑定例外，需要注意甄别。在ES6的箭头函数中并不会使用上列的绑定规则，而是根据**当前的词法作用域**来决定this的绑定对象。简单点说，就是**箭头函数会直接继承上文函数调用的this绑定**。



##### 4、箭头函数与普通函数区别：

> 1. 没有 this

**箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。**这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this。



> 2. 没有 arguments

箭头函数没有自己的 arguments 对象，这不一定是件坏事，因为箭头函数可以访问外围函数的 arguments 对象：

```js
function constant() {
    return () => arguments[0]
}

var result = constant(1);
console.log(result()); // 1
```



> 3. 不能通过 new 关键字调用

JavaScript 函数有两个内部方法：[[Call]] 和 [[Construct]]。

当通过 new 调用函数时，执行 [[Construct]] 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。

当直接调用的时候，执行 [[Call]] 方法，直接执行函数体。

箭头函数并没有 [[Construct]] 方法，不能被用作构造函数，如果通过 new 的方式调用，会报错。

```js
var Foo = () => {};
var foo = new Foo(); // TypeError: Foo is not a constructor
```



> 4. 没有 new.target

因为不能使用 new 调用，所以也没有 new.target 值。

关于 new.target，可以参考 [es6.ruanyifeng.com/#docs/class…](http://es6.ruanyifeng.com/#docs/class#new-target-属性)



> 5. 没有原型

由于不能使用 new 调用箭头函数，所以也没有构建原型的需求，于是箭头函数也不存在 prototype 这个属性。

```js
var Foo = () => {};
console.log(Foo.prototype); // undefined
```



> 6. 没有 super

连原型都没有，自然也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的，不过跟 this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。



##### 5、手写 `bind`函数

```js
// slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。

Function.prototype.bind1 = function() {
    // 将参数解析成数组, arguments 是一个列表
    const args = Array.prototype.slice.call(arguments)

    // 获取 this (取出数组第一项，数组剩余的就是要传递的参数)
    const t = args.shift()
    const self = this // 当前函数

    // 返回一个函数
    return function() {
        // 执行原函数，并返回结果
        return self.apply(t, args)
    }
}

function fn(a, b) {
    console.log(this)
    console.log(a, b)
}
let obj = {
    name: 'haha'
}
let fn1 = fn.bind1(obj, "aaa", "ccc")
fn1()
```



##### 6、闭包在开发过程中的应用场景

> 闭包：闭包是指有权访问**另一个函数作用域**中的变量的**函数**。

两种情况：

1. 函数作为参数被传递

2. 函数作为返回值被返回

   > 闭包：**所有自由变量的查找，是在函数定义的地方向上级作用域查找，不是在执行的地方**

> 应用场景

1、为节点绑定 click 事件

```html
<body>
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
    </ul>
</body>
<script>
    // var lis = document.getElementsByTagName("li");
    // for (var i = 0; i < lis.length; i++) {
    //     lis[i].onclick = function() {
    //         console.log(i);
    //     }
    // }

    var lis = document.getElementsByTagName("li");
    for (var i = 0; i < lis.length; i++) {
        (function(i) {
            lis[i].onclick = function() {
                console.log(i)
            }
        })(i);
    }
```

2、延续局部变量的寿命

```js
var report = function(src) {
    var img = new Image();
    img.src = src;
}
report('http://xxx.com/getUserInfo');

/* 这段代码在运行时，发现在一些低版本浏览器上存在bug，会丢失部分数据上报，原因是img是report函数中的局部变量，当report函数调用结束后，img对象随即被销毁，而此时可能还没来得及发出http请求，所以此次请求就会丢失。
因此，我们使用闭包把img对象封闭起来，就可以解决数据丢失的问题：*/

var report = (function() {
    var imgs = [];
    return function(src) {
        var img = new Image();
        imgs.push(img);
        img.src = src;
    }
})()
```

3、对结果进行缓存

```js
var fn=function(){
    var sum=0;
    for(var i=0;i<arguments.length;i++){
        sum+=arguments[i];
    }
    return sum;
}
console.log(fn(1,2));//3
 
//优化版本
var fn=(function(){
    var cache={}//将结果缓存到该对象中
    return function(){
        var str=JSON.stringify(arguments);
        if(cache[str]){//判断缓存中是否存在传递过来的参数，存在直接返回结果，无需计算
            return cache[str];
        }else{//进行计算并返回结果
            var sum=0;
            for(var i=0;i<arguments.length;i++){
                sum+=arguments[i];
            }
            return cache[str]=sum;
        }
    }
})()
```



##### *** 词法作用域

词法作用域意味着作用域是由书写代码时函数声明的位置来决定的  

##### *** 变量提升

引擎会在解释 JavaScript 代码之前首先对其进行编译。 编译阶段中的一部分工作就是找到所有的声明， 并用合适的作用域将它们关联起来  。

函数声明会被提升， 但是函数表达式却不会被提升 。

函数会首先被提升， 然后才是变量 ，所以出现同名的函数和变量，**函数会覆盖变量的值**。但是，出现在**后面的函数声明**还是可以**覆盖前面**的。  

> 一个普通块内部的函数声明通常会被提升到所在作用域的顶部， 这个过程不会像下面的代
> 码暗示的那样可以被条件判断所控制：  
>
> ```js
> foo(); // "b"
> var a = true;
> if (a) {
> 	function foo() { console.log("a"); }
> }
> else {
> 	function foo() { console.log("b"); }
> }
> ```
>
> 所有的声明（变量和函数） 都会被“移动” 到各自作用域的最顶端， 这个过程被称为提升 。



闭包：

在定时器、 事件监听器、Ajax 请求、 跨窗口通信、 Web Workers 或者任何其他的异步（或者同步） 任务中， 只要使
用了回调函数， 实际上就是在使用闭包！  

#### 四、异步和单线程

1. 同步和异步区别

2. promise

   1. 回调地狱

   2. promise

3. 前端使用异步的场景有哪些？

   1. 网络请求 
   2. 定时任务

##### js 异步与同步的略述

[JavaScript异步机制详解](https://juejin.cn/post/6844903556084924423)



##### 1、Generator函数

Generator函数是 ES6 提供的一种异步编程解决方案，形式上也是一个普通函数，但有几个显著的特征：

 -- function关键字与函数名之间有一个星号 "*" （推荐紧挨着function关键字）

 -- 函数体内使用 yield 表达式，定义不同的内部状态 （可以有多个yield）

 -- 直接调用 Generator函数并不会执行，也不会返回运行结果，而是返回一个遍历器对象（Iterator Object）

 -- 依次调用遍历器对象的next方法，遍历 Generator函数内部的每一个状态

```js
function* gen() {
    yield 'hello'
    yield 'world'
    return 'ending'
}

let it = gen()

it.next()   // {value: "hello", done: false}
it.next()   // {value: "world", done: false}
it.next()   // {value: "ending", done: true}
it.next()   // {value: undefined, done: true}

// 执行过程如下：
/*
第一次调用next方法时，内部指针从函数头部开始执行，遇到第一个 yield 表达式暂停，并返回当前状态的值 'hello'
 
第二次调用next方法时，内部指针从上一个（即第一个） yield 表达式开始，遇到第二个 yield 表达式暂停，返回当前状态的值 'world'
 
第三次调用next方法时，内部指针从第二个 yield 表达式开始，遇到return语句暂停，返回当前状态的值 'end'，同时所有状态遍历完毕，done 属性的值变为true
 
第四次调用next方法时，由于函数已经遍历运行完毕，不再有其它状态，因此返回 {value: undefined, done: true}。如果继续调用next方法，返回的也都是这个值
*/
```

yield 表达式和return语句的区别

```
相似：都能返回紧跟在语句后面的那个表达式的值
区别：
-- 每次遇到 yield，函数就暂停执行，下一次再从该位置继续向后执行；而 return 语句不具备记忆位置的功能
-- 一个函数只能执行一次 return 语句，而在 Generator 函数中可以有任意多个 yield
```



##### 2、promise进阶

> promise.then()返回的新 promise 的结果状态由什么决定?  （注意：在执行函数中必须指明是 resolve() 还是reject）
>
> **由 then()指定的回调函数执行的结果决定**  
>
> 1. 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常
> 2. 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值
> 3. 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果 (可以返回一个pendding的promise，重点promise链)
> 4. 如果前一个Promise对象没有返回状态（resolve或者reject），也没有抛错（throw error），也没有返回具体数值，我们则认为它返回 了一个undefined，则undefined将作为后一个Promise对象的输入，执行第一个参数方法（resolve）
>
> Promise 是 JS 中进行异步编程的新的解决方案(旧的是谁?)  ，从语法上来说: Promise 是一个构造函数，从功能上来说: promise 对象用来封装一个异步操作并可以获取其结果 。

```js
console.log(1);

setTimeout(() => {
  console.log(2);
  Promise.resolve().then(() => {
    console.log(3)
  });
});

new Promise((resolve, reject) => {
  console.log(4)
  resolve(5)
}).then((data) => {
  console.log(data);
})

setTimeout(() => {
  console.log(6);
})

console.log(7);

// 1 4 7 5 2 3 6
```

```js
console.log(1)
process.nextTick(() => {
  console.log(8)
  setTimeout(() => {
    console.log(9)
  })
})
setTimeout(() => {
  console.log(2)
  new Promise(() => {
    console.log(11)
  })
})
let promise = new Promise((resolve,reject) => {
  setTimeout(() => {
    console.log(10)
  })
  resolve()
  console.log(4)
})
fn()
console.log(3)
promise.then(() => {
  console.log(12)
})
function fn(){
  console.log(6)
}

/*
    1
    4
    6
    3
    8
    12
    2
    11
    10
    9
*/
```



##### 3、async / await

>  async 函数  

1. 函数的**返回值**为 **promise 对象**
2. promise 对象的结果由 async 函数执行的返回值决定  

>  await 表达式  （相当于then来用）

1. await 右侧的表达式一般为 promise 对象, 但也可以是其它的值
2. 如果表达式是 promise 对象, await 返回的是 **promise 成功的值**  
3. 如果表达式是其它值, 直接将此值作为 await 的返回值  

**注意** 

1. await 必须写在 async 函数中, 但 async 函数中可以没有 await
2. 如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try...catch 捕获处理  



##### 4、event loop

事件循环机制

> Javascript单线程任务被分为同步任务和异步任务.
>
> - 同步任务会**在调用栈**(也被称为执行栈) 中按照顺序等待主线程依次执行.
> - 异步任务会甩给在WebAPIs处理,处理完后有了结果后，将注册的回调函数放入**任务队列**中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。
>
> 一个循环周期就是微任务结束开启另外一个宏任务
>
> 1.执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）； 
>
> 2.全局Script代码执行完毕后，调用栈Stack会清空；
>
> 3.从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；
>
> 4.继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行； 
>
> 5.microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；
>
> 6.取出宏队列macrotask queue中位于队首的任务，放入Stack中执行； 
>
>  7.执行完毕后，调用栈Stack为空；
>
> 循环 3- 7



##### 5、微任务/宏任务

什么是宏任务和微任务，有什么区别？

宏任务：setTimeout，setInterval，Ajax，DOM事件

微任务：promise，async/await

> 微任务比宏任务更早触发。

微任务：DOM渲染前触发，是ES6规定的

宏任务：DOM渲染后触发，是浏览器规定的

* 微任务，宏任务和DOM渲染在Event Loop的过程
  * 执行同步任务，call back清空
  * 执行当前微任务
  * 尝试dom渲染
  * 触发Even Loop

#### 5、setTimeout 与 setInterval

setInterval的缺点（主要）：

* 使用setInterval时，某些间隔会被跳过；
* 可能多个定时器会连续执行；



> * 1.setInterval对自己调用的代码是否报错漠不关心。即使调用的代码报错了，它依然会持续的调用下去
> * 2.setInterval无视网络延迟。在使用ajax轮询服务器是否有新数据时，必定会有一些人会使用setInterval，然而无论网络状况如何，它都会去一遍又一遍的发送请求，"如果网络状况不良，一个请求发出，还没有返回结果，它会坚持不懈的继续发送请求，最后导致的结果就是请求堆积。
> * 3.setInterval并不定时。如果它调用的代码执行的时间小于定时的时间，它会跳过调用，这就导致无法按照你需要的执行次数或无法得到你想要的结果。

使用 setTimeout() 来代替setInterval()

* 1.写一个interval方法

```js
var timer = null
interval(func, wait){
    var interv = function(){
        func.call(null);
        timer=setTimeout(interv, wait);
    };
    timer= setTimeout(interv, wait);
 },
```

* 2.和setInterval()一样使用它

```js
interval(function () {},20)
```

* 3.终止定时器

```js
if(timer){
    window.clearTimeout(timer);
    timer=null;
}
```



#### 五、ajax

##### 手写一个简单的ajax

* XMLHttpRequest

  ```js
  // get请求
  const xhr = new XMLHttpRequest()
  xhr.open('GET', '/api', false)
  xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
          if (xhr.status === 200) {
              alert(xhr.responseText)
          }
      }
  }
  xhr.send()
  ```

  **readyStae状态的介绍:**

  ```js
   0 － （未初始化）还没有调用send()方法
   1 － （载入）已调用send()方法，正在发送请求
   2 － （载入完成）send()方法执行完成，已经接收到全部响应内容
   3 － （交互）正在解析响应内容
   4 － （完成）响应内容解析完成，可以在客户端调用了
  ```

##### 跨域

1. 什么是跨域

* 同源策略：ajax请求时，**浏览器要求**当前网页和 server 必须同源（浏览器的安全策略）

* 同源：**协议、域名、端口**，三者必须一致

  ```js
  // 前端：http://a.com:8080 ; server: https://b.com/api/xxx (跨域)
  // 前端：http://a.com/a; server: http://a.com/b (不跨域)
  ```

  * 注意：图片、css、js 是可以跨域的，无视同源策略、

* 跨域：所有的跨域必须经过 server 端的允许和配合，未经 server 端允许就实现跨域，说明浏览器有漏洞，危险信号！

> Question1：
>
> 出于浏览器的同源策略限制，浏览器会拒绝跨域请求。
>
> 严格的说，浏览器并不是拒绝所有的跨域请求，实际上**拒绝**的是**跨域的读操作**。浏览器的同源限制策略是这样执行的：
>
> - 通常浏览器允许进行跨域写操作（Cross-origin writes），如链接，重定向；
> - 通常浏览器允许跨域资源嵌入（Cross-origin embedding），如 img、script 标签；
> - 通常浏览器不允许跨域读操作（Cross-origin reads）。
>
> 
>
> Question2：
>
> 为什么有跨域需求?
>
> 场景 —— 工程服务化后，不同职责的服务分散在不同的工程中，往往这些工程的域名是不同的，但一个需求可能需要对应到多个服务，这时便需要调用不同服务的接口，因此会出现跨域。

2. 如何实现跨域？

   通常，最常用的跨域方式有以下三种：JSONP、CORS、postMessage。

* JSONP

  ![](D:\Document\00_Notes\000前端笔记\99面试笔记\media\jsonp解决跨域.png)

  * 原理

    > 虽然因为同源策略的影响，不能通过XMLHttpRequest请求不同域上的数据（Cross-origin reads）。但是，在页面上引入不同域上的js脚本文件却是可以的（Cross-origin embedding）。因此在js文件载入完毕之后，触发回调，可以将需要的data作为参数传入。

  * 实现方式（需前后端配合）

  * 优缺点

    > 优点：兼容性好（兼容低版本IE）
    > 缺点：1.JSONP只支持 GET 请求； 
    >
    > ​			2.XMLHttpRequest相对于 JSONP 有着更好的错误处理机制

  **原理**

  script、link、image 不存在跨域请求的限制。

  **过程**

  1、在请求跨域资源的时候，我们生成一个 script 标签，将它的 src 设置为请求参数，插入 DOM 中发起请求

  2、要求服务器返回一个 .js 文件，格式为 `function_name(data)`， data 就是我们想要获得的数据，一般是 JSON 格式

  3、在全局作用域绑定一个函数，函数名就是上面的 `function_name`，这个函数是一个闭包，记住了调用位置的作用域链，这样我们就可以在这个闭包里调用业务代码

  4、收到服务器返回的文件后浏览器自动解析执行，执行这个闭包

  ![](media\jsonp原理.png)

* CORS（服务端支持）

  需要增加一些 HTTP 头，让服务器能声明允许的访问来源。

  Access-Control-Allow-Origin: * 表明该资源可以被任意外域访问。

  详见链接 [掘金](https://juejin.cn/post/6844903496521613320)

  **案例如下：**

  ```js
  var express = require('express')
  
  // 90端口的服务，将当前目录作为http服务
  var app = express()
  app.use(express.static(__dirname))
  app.listen(90)
  
  // 91端口的服务返回数据
  var app2 = express();
  app2.get("/", function() {
      res.send("你好")
  })
  app2.listen(91)
  ```

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Document</title>
  </head>
  <body>
      <h1>Hello!!!</h1>
      <script>
          fetch("http://localhost:91/")
              .then(res => res.text())
              .then(data => alert(data))
      </script>
  </body>
  </html>
  ```



  ```
  此时，无法正确的弹出出 “你好”，浏览器会报错。

  **解决方法一：在接口的服务端修改响应头**（CORS）
  
  ```js
  var express = require('express')
  
  // 90端口的服务，将当前目录作为http服务
  var app = express()
  app.use(express.static(__dirname))
  app.listen(90)
  
  // 91端口的服务返回数据
  var app2 = express();
  app2.get("/", function() {
      res.header("Access-Control-Allow-Origin", "*")
      res.send("你好")
  })
app2.listen(91)
  ```

  **解决方法二：**（JSONP）

  ```js
  var express = require('express')
  
  // 90端口的服务，将当前目录作为http服务
  var app = express()
  app.use(express.static(__dirname))
  app.listen(90)
  
  // 91端口的服务返回数据
  var app2 = express();
  app2.get("/", function() {
      var funcName = res.query.callback;
      res.send(funcName + "('你好')")
      // f('你好')
  })
app2.listen(91)
  ```

  ```html
  <!DOCTYPE html>
  <html lang="en">
  
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Document</title>
  </head>
  
  <body>
      <h1>Hello!!!</h1>
      <script>
          f(data) {
              alert(data)
          }
      </script>
      <script src="http://localhost:91?callback=f"></script>
  </body>
  
  </html>
  ```



#### 六、浏览器缓存

参考链接[掘金](https://juejin.cn/post/6844903516826255373)

* cookie缺点

  * 最大存储4kb
  * 可设置失效时间，没有设置的话，默认是关闭浏览器后失效
  * http请求时需要发送到服务端，增加数据请求量
  * 只能用document.cookie = ' xxx = xxx'，来修改，有的话就覆盖，没有的话就追加

* localStorage

  > `localStorage`只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。
  >
  > ```js
  > localStorage.setItem("b","isaac");	//设置b为"isaac"
  > var b = localStorage.getItem("b");	//获取b的值,为"isaac"
  > var a = localStorage.key(0); 		// 获取第0个数据项的键名，此处即为“b”
  > localStorage.removeItem("b");		//清除c的值
  > localStorage.clear();				//清除当前域名下的所有localstorage数据
  > ```

* sessionStorage

  > sessionStorage`比`localStorage`更严苛一点，除了协议、主机名、端口外，还要求在同一**窗口**（也就是浏览器的标签页）下。

  * HTML5专门为存储而设计，最大存储5M
  * 不会随着http请求而发送出去

  作用域

  cookie、localStorage和sessionStorage 三者之间的区别

  * （1）生命周期：
    * cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效
    * localStorage数据会永久存储，除非代码或者手动删除
    * sessionStorge数据只存在于当前会话，浏览器关闭则清空
  * （2）存放数据大小：
    * cookie：4KB左右
    * localStorage和sessionStorage：可以保存5MB的信息。
  * （3）http请求
    * cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题
    * localStorage和sessionStorage：仅在客户端（即浏览器）中保存，不参与和服务器的通信

  **总结**

  1. 从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比storage更好用的。其他情况下，可以使用storage，就用storage。
  2. localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来跨页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。

  **特别注意：**

  服务端的session，和前端的sessionStorage是两个东西,session才是存放在服务端，sessionStroage放在客户端。

##### cookie

![](media\cookie.png" style="zoom:50%;")

##### webStorage

![](media\localStorage、sessionStorage优缺点.png" style="zoom: 80%;")

![](media\webStorage优点.png" style="zoom: 80%;" )

##### 强缓存和协商缓存

![](D:\Document\00_Notes\000前端笔记\99面试笔记\media\缓存头部对比.PNG)

[强缓存、协商缓存](https://www.cnblogs.com/chengxs/p/10396066.html)

> 浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下：
>
> 1. http 缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在 respone header 头中回传资源的缓存参数；
> 2. 第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200。服务器并不会返回资源信息，浏览器继续从缓存加载资源；
> 3. 否则就把请求参数加到 request header 头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。

[缓存介绍----掘金](https://juejin.cn/post/6914271764012859406)

[缓存介绍----掘金](https://juejin.cn/post/6932115786601332749)（整理的不错）

web缓存可大致分为：数据库缓存、服务器缓存、浏览器缓存；

浏览器缓存由分为：HTTP缓存、indexDB、localstoreage、cookie、pwa等。

* 浏览器缓存流程

* 强缓存

  > 浏览器第一次向服务器访问资源，服务器会返回资源并且在 Response Headers 中加入Cache-Control（max-age、no-cache、no-store、private、public）。
  >
  > 
  >
  > max-age：指定一个时间长度，在这个时间段内缓存是有效的，单位是s。例如设置 Cache-Control:max-age=600，也就是说缓存有效期为600s。在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取；
  >
  > no-cache：可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用；
  >
  > no-store：彻底得禁用缓冲，本地和代理服务器都不缓冲，每次都从服务器获取。
  >
  > 
  >
  > 浏览器再次请求，浏览器判断这些请求参数，命中强缓存就直接200。

* 协商缓存

  > 浏览器第一次向服务器访问资源，服务器会返回资源和资源标识；再次请求时，带着资源标识，服务器判断是否命中协商缓存，返回304（命中）或者返回资源和新的资源标识。
  >
  > 资源标识：在Response Header 中，有两种，Last-Modified（资源的最后修改时间）、Etag资源的唯一标识（一个字符串，表示唯一）

![](media\浏览器缓存1.jpg)

![](media\浏览器缓存2.jpg)

#### 七、Web API

* 获取dom

  ```js
  // 获取特殊的元素
  const body = document.body					// 返回body对象
  const html = document.documentElement		// 返回html元素 
  ```

  

  ```js
  const div1 = document.getElementById('div1')
  const divList = document.getElementByTagName('div')		// 获取过来元素对象的集合，以伪数组的形式存储的
  const containerList = document.getElementByClassName('.container')
  const aaa = document.querySelector('.aaa')							// 根据指定选择器返回第一个元素
  const pList = document.querySelectorAll('p')			// 根据指定选择器返回
  // 后面两个选择器需要加入符号
  ```

* attribute

  ```js
  p.getAttribute('data-name')
  p.setAttribute('data-name', 'haha')
  p.removeAttribute('data-name');
  ```

* dom结构操作

  ```js
  const newP = document.createElement("newP");
  ```







#### 八、Restful API

* 一种新的API设计方法

  * 传统API设计：把每一个url当作一个功能  

  * Reatful API设计：**把每个 url 当作一个唯一的资源标识**

    > 传统：/api/list?pageIndex=2
    >
    > Restful API：/api/list/2

    传统：

    > post请求：/api/create-blog
    >
    > post请求：/api/update-blog?id=100
    >
    > get请求：/api/get-blog?id=100

    Restful API

    > post请求：/api/blog
    >
    > post请求：/api/blog/100
    >
    > get请求：/api/blog/100

* 如何设计成一个资源

  * 尽量不用url参数
  * 用method表示操作类型

  > 通过向服务器提交的请求类型来表示增删改查这些操作
  >
  > get：请求资源
  >
  > post：新建资源
  >
  > put：修改资源（更新资源）/ patch ：修改资源
  >
  > delete：删除资源



#### 十、性能优化

##### 1、函数防抖

[相关文档----掘金](https://juejin.cn/post/6914186870687694855)

防抖：**任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。**

例子：有个输入框,输入之后会调用接口,获取联想词。但是,因为频繁调用接口不太好,所以我们在代码中使用防抖功能,只有在用户输入完毕的一段时间后,才会调用接口,出现联想词。

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>防抖</title>
</head>
<body>
  <button id="debounce">点我防抖！</button>

  <script>
    window.onload = function() {
      // 1、获取这个按钮，并绑定事件
      var myDebounce = document.getElementById("debounce");
      myDebounce.addEventListener("click", debounce(sayDebounce));
    }

    // 2、防抖功能函数，接受传参
    function debounce(fn) {
      // 4、创建一个标记用来存放定时器的返回值
      let timeout = null;
      return function() {	// 节流函数 / 真正的事件回调函数，this 是发生事件的标签
        // 5、每次当用户点击/输入的时候，把前一个定时器清除
        clearTimeout(timeout);
        // 6、然后创建一个新的 setTimeout，
        // 这样就能保证点击按钮后的 interval 间隔内
        // 如果用户还点击了的话，就不会执行 fn 函数
        timeout = setTimeout(() => {
          fn.call(this, arguments);
        }, 1000);
      };
    }

    // 3、需要进行防抖的事件处理
    function sayDebounce() {
      // ... 有些需要防抖的工作，在这里执行
      console.log("防抖成功！");
    }

  </script>
</body>
</html>
```



##### 2、函数节流

节流：**指定时间间隔内只会执行一次任务。**

例子：1、懒加载要监听计算滚动条的位置,使用节流按一定时间的频率获取。

​			2、用户点击提交按钮,假设我们知道接口大致的返回时间的情况下,我们使用节流,只允许一定时间内点击一次。

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>节流</title>
</head>
<body>

  <button id="throttle">点我节流！</button>

  <script>
    window.onload = function() {
      // 1、获取按钮，绑定点击事件
      var myThrottle = document.getElementById("throttle");
      myThrottle.addEventListener("click", throttle(sayThrottle));
    }

    // 2、节流函数体
    function throttle(fn) {
      // 4、通过闭包保存一个标记
      let canRun = true;
      return function() {
        // 5、在函数开头判断标志是否为 true，不为 true 则中断函数
        if(!canRun) {
          return;
        }
        // 6、将 canRun 设置为 false，防止执行之前再被执行
        canRun = false;
        // 7、定时器
        setTimeout( () => {
          fn.call(this, arguments);
          // 8、执行完事件（比如调用完接口）之后，重新将这个标志设置为 true
          canRun = true;
        }, 1000);
      };
    }

    // 3、需要节流的事件
    function sayThrottle() {
      console.log("节流成功！");
    }

  </script>
</body>
</html>
```



##### 3、性能优化的方法

[掘金-前端性能优化](https://juejin.cn/post/6844903639115366408)





## JS模块



```
js 中现在比较成熟的有四种模块加载方案。

第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是
服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式
加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。

第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定
义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。

第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js
的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。参考60

第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。
```



####  AMD 和 CMD 规范的区别？

它们之间的主要区别有两个方面。

（1）第一个方面是在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇 就近依赖，只有在用到某个模块的时候再去 require。

（2）第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于 模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句 的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。

```js
// CMD
define(function(require, exports, module) {
  var a = require("./a");
  a.doSomething();
  // 此处略去 100 行
  var b = require("./b"); // 依赖可以就近书写
  b.doSomething();
  // ...
});

// AMD 默认推荐
define(["./a", "./b"], function(a, b) {
  // 依赖必须一开始就写好
  a.doSomething();
  // 此处略去 100 行
  b.doSomething();
  // ...
});
```



#### ES6 模块与 CommonJS (node)模块区别

- 1.CommonJS 模块输出的是一个**值的拷贝**，ES6 模块输出的是**值的引用**。

  CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。

  ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。

- 2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

  CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。



### ES6规范	

+ 使用 export default 和 export 向外暴露成员：
+ 使用 import 模块名称 from ‘模块标识符'		import  '表示路径'

```javascript
export default {
	name: 'zs',
	age: 20
}
import mm from './test.js'
console.log(mm)
```



**注意：**
1、export default 向外暴露的成员，可以使用任意变量来接受
2、在一个模块中，只允许 export default 向外暴露一次
3、在一个模块中，可以同时使用 export default 向外暴露成员，也可以使用 export 向外暴露
4、使用 export 向外暴露成员，可以向外暴露多个成员，但是只能够使用 { } 的形式来接收，叫做【按需导出】，有些变量不需要的时候，可以不在{ } 中定义
5、使用 export 导出的成员，必须按照导出的时候的名称，来使用 { } 按需接受。
6、使用 export 导出的成员，如果想换个名称来接收，可以使用 as 来起别名



在node中使用 var 名称 = require('模块标识符')
module.exports 和 exports 来向外暴露成员

### 区别（重点）***

> 在 node 中，使用 exports 和 module.exports 来导出成员， 使用require来导入
>
> 在 ES6 中，使用 export 和 export default 来导出成员，使用 import 来导入

### node模块中的导入导出

`Node`里面的模块系统遵循的是`CommonJS`规范。

>  `CommonJS`定义的模块分为: 模块标识(`module`)、模块定义(`exports`) 、模块引用(`require`)



>  在 node 中，每个模块内部都有一个自己的 module 对象，该 module 对象中，有一个成员叫：exports， 也是一个对象。
>
>  也就是说，如果你需要对外导出成员，只需要把导出的成员挂载到 module.exports 中

```js
// foo.js

//var moudule = {
//	exports: {
//		foo: "bar"
//		add: function
//	}
//}

module.exports.foo = 'bar'
module.export.add = function(x, y){
	return x +y;   
}
```

```js
// main.js
var fooExports = require(./foo)
console.log(fooExports)		// {foo: 'bar', add: [function]}
```

默认在代码最后一句，`return module.exports` 

谁来 require 我，谁就得到 module.exports

####  exports 和 module.exports

node为了简化代码，专门提供了一个变量：exports = module.exports

>  exports = module.exports = {};

现在就可以这么来书写：

```js
exports.foo = 'bar'
exports.add = function(x, y) {
	return x + y;
}
```



> **导出对象最终以`module.exports`为准**

然后呢，为了避免糊涂，尽量都用 `module.exports` 导出，然后用`require`导入。

### ES6中的模块导出导入

说实话，在es中的模块，就非常清晰了。不过也有一些细节的东西需要搞清楚。
比如 `export` 和 `export default`，还有 导入的时候，`import a from ..`,`import {a} from ..`，总之也有点乱，那么下面我们就开始把它们捋清楚吧。

#### export 和 export default

首先我们讲这两个导出，下面我们讲讲它们的区别

1. export与export default均可用于导出常量、函数、文件、模块等
2. 在一个文件或模块中，export、import可以有多个，export default仅有一个
3. 通过export方式导出，在导入时要加{ }，export default则不需要
4. export能直接导出变量表达式，export default不行。

```js
'use strict'
//导出变量
export const a = '100';  
 
 //导出方法
export const dogSay = function(){ 
    console.log('wang wang');
}
 
 //导出方法第二种
function catSay(){
   console.log('miao miao'); 
}
export { catSay };
 
//export default导出
const m = 100;
export default m; 
//export defult const m = 100;// 这里不能写这种格式。
```

## 前端安全

### 一、XSS

xss: 跨站脚本攻击（Cross Site Scripting)

> 在网页中恶意注入代码，使用户加载执行。

目的可能有：

1. 获取当前用户在这个网站上的cookies， 从而拿到用户的敏感性息。
2. 以用户的身份发起一些非用户本人本意的操作请求，比如删除好友，发私信等。
3. 实现DDos攻击。

根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。

#### 1、DOM 型 XSS

DOM 型 XSS 的攻击步骤：

1. 攻击者**构造出特殊的 URL，其中包含恶意代码**。
2. 用户打开带有恶意代码的 URL。
3. 用户浏览器接收到响应后解析执行，**前端 JavaScript 取出 URL 中的恶意代码并执行**。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

>  DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。



#### 2、反射型 XSS

反射型 XSS 的攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL 时，**网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器**。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

>  反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。
>
>  反射型 XSS 漏洞常见于通过 URL **传递参数的功能，如网站搜索、跳转**等。
>
>  由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。
>
>  POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。



#### 3、存储型 XSS

存储型 XSS 的攻击步骤：

1. 攻击者将**恶意代码提交到目标网站的数据库**中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

> 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。



#### 防御手段

1. 使用`HTML`转义，对所有外部插入的代码都做一次转义，`script`，`& < > " ' /` 等危险 字符做过滤和专题替换，避免使用`innerHTML`、`document.write`等方法，使用安全性较高的`textContent `、`setAttribute`等方法代替。

2. 开启csp方法。在HTTP响应头中设置Content-Security-Policy:

   ```json
   Content-Security-Policy: scrippt-src `self`
   ```

   > 禁止加载外域代码，防止复杂的攻击逻辑。
   >
   > 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。
   >
   > 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。
   >
   > 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。
   >
   > 合理使用上报可以及时发现 XSS，利于尽快修复问题。
   >
   > 

#### 思考

1. XSS 防范是后端 RD 的责任，后端 RD 应该在所有用户提交数据的接口，对敏感字符进行转义，才能进行下一步操作。

> 不正确。因为：
>
> - 防范存储型和反射型 XSS 是后端 RD 的责任。而 DOM 型 XSS 攻击不发生在后端，是前端 RD 的责任。防范 XSS 是需要后端 RD 和前端 RD 共同参与的系统工程。
> - 转义应该在输出 HTML 时进行，而不是在提交用户输入时。

1. 所有要插入到页面上的数据，都要通过一个敏感字符过滤函数的转义，过滤掉通用的敏感字符后，就可以插入到页面中。

> 不正确。 不同的上下文，如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等，所需要的转义规则不一致。 业务 RD 需要选取合适的转义库，并针对不同的上下文调用不同的转义规则。



### 二、csrf

csrf：跨站点请求伪造（Cross-Site Request Forgeries)

#### 原理

![](media\csrf攻击.jpg)



CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。**利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。**



一个典型的CSRF攻击有着如下的流程：

- [受害者登录a.com](http://xn--a-f38al5vkzdt61bv7l.com)，并保留了登录凭证（Cookie）。
- [攻击者引诱受害者访问了b.com](http://xn--b-nv6ao4io8bp6po6e00mu47cda4311avpa330h.com)。
- [b.com](http://b.com) 向 [a.com](http://a.com) 发送了一个请求：[a.com/act=xx。浏览器会…](http://a.com/act=xx。浏览器会默认携带a.com的Cookie。)
- a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
- a.com以受害者的名义执行了act=xx。
- 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。



#### 防御手段

1. 设置 cookie 的 sameSite 属性。它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie。

   **Samesite=Strict**

   `Strict`最为严格，**完全禁止第三方 Cookie**，跨站点时，任何情况下都不会发送 Cookie。换言之，**只有当前网页的 URL 与请求目标一致，才会带上 Cookie。**

   

   **Samesite=Lax**

   `Lax`规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。

   导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。

   | 请求类型  |                 示例                 |    正常情况 | Lax         |
   | :-------- | :----------------------------------: | ----------: | :---------- |
   | 链接      |         `<a href="..."></a>`         | 发送 Cookie | 发送 Cookie |
   | 预加载    | `<link rel="prerender" href="..."/>` | 发送 Cookie | 发送 Cookie |
   | GET 表单  |  `<form method="GET" action="...">`  | 发送 Cookie | 发送 Cookie |
   | POST 表单 | `<form method="POST" action="...">`  | 发送 Cookie | 不发送      |
   | iframe    |    `<iframe src="..."></iframe>`     | 发送 Cookie | 不发送      |
   | AJAX      |            `$.get("...")`            | 发送 Cookie | 不发送      |
   | Image     |          `<img src="...">`           | 发送 Cookie | 不发送      |

   **Samesite=None**

   Chrome 计划将`Lax`变为默认设置。这时，网站可以选择显式关闭`SameSite`属性，将其设为`None`。不过，前提是必须同时设置`Secure`属性（Cookie 只能通过 HTTPS 协议发送），否则无效。

   下面的设置无效。

   > ```bash
   > Set-Cookie: widget_session=abc123; SameSite=None
   > ```

   下面的设置有效。

   > ```bash
   > Set-Cookie: widget_session=abc123; SameSite=None; Secure
   > ```

2. CSRF Token

   服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了，否则又会被攻击者冒用。因此，存放在**Local / session storage** 中，每次请求的时候都要带上，服务器需要判断Token的有效性。

3. 服务端判断请求头中的 Referer 和 Origin ，判断请求来源。

4. 手机验证码、邮箱验证等二次验证。

## 计算机网络

##### 常见的状态码

* 1xx	服务器收到请求
* 2xx    请求成功
  * 200成功
* 3xx    重定向
  * 301永久重定向（配合location，浏览器自动处理）
  * 302临时重定向（配合location，浏览器自动处理）
  * 304资源未被修改
* 4xx    客户端错误
  * 403没有权限
  * 404资源未找到
* 5xx    服务端错误
  * 500服务器错误
  * 504网关超时

关于 301(永久重定向) 和 302(临时重定向) 区别：

>  我们之前网站的域名是 a.com，现在替换成了 b.com。但是用户并不知道域名改了，所以还是在浏览器里输入 a.com，Web服务器（apache 或者 ngnix）在收到请求后，在响应中包含：
>
>  - 状态码 301 及 b.com。用户的浏览器在收到响应后，**自动将输入栏网址改变为 b.com。**
>  - 或者状态码 302 及 b.com。用户的浏览器在收到响应后，**输入栏仍是显示旧网址，**但是显示的是 b.com的内容。

1. 301 和 302 区别

   301 是永久重定向，302是一种临时重定向。302表示被访问的资源暂时不能被访问。301表示被访问的资源被永久的删除了，搜索引擎在抓取的时候，会将新的url地址替换成老的url地址，可以在返回的响应的 location 首部去获取到返回的地址。比如，访问http://www.baidu..com 会自动跳转到https://www.baidu.com。

2. http 请求方式（get/ post / put/delete)



##### http常见的 header 有哪些？

* genaral headers

  > Cache-Control——控制缓存的行为； [详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)
  > Connection——决定当前的事务完成后，是否会关闭网络连接； [详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection)
  > Date——创建报文的日期时间； [详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Date)
  > Keep-Alive——用来设置超时时长和最大请求数；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Keep-Alive)
  > Via——代理服务器的相关信息；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Via)
  > Warning——错误通知；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Warning)
  > Trailer——允许发送方在分块发送的消息后面添加额外的元信息； [详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Trailer)
  > Transfer-Encoding——指定报文主体的传输编码方式；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Transfer-Encoding)
  > Upgrade——升级为其他协议；

* 常见的Request Headers

  > Accept——客户端可以处理的内容类型；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept)
  > Accept-Charset——客户端可以处理的字符集类型；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Charset)
  > Accept-Encoding——客户端能够理解的内容编码方式；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Encoding)
  > Accept-Language——客户端可以理解的自然语言；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language)
  > Authorization——Web 认证信息；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Authorization)
  > Cookie——通过Set-Cookie设置的值；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie)
  > DNT——表明用户对于网站追踪的偏好；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/DNT)
  > From——用户的电子邮箱地址；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/From)
  > Host——请求资源所在服务器；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Host)
  > If-Match——比较实体标记（ETag）；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Match)
  > If-Modified-Since——比较资源的更新时间；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since)
  > If-None-Match——比较实体标记（与 If-Match 相反）；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match)
  > If-Range——资源未更新时发送实体 Byte 的范围请求；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Range)
  > If-Unmodified-Since——比较资源的更新时间（与 If-Modified-Since 相反）；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since)
  > Origin——表明了请求来自于哪个站点；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin)
  > Proxy-Authorization——代理服务器要求客户端的认证信息；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Proxy-Authorization)
  > Range——实体的字节范围请求；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Range)
  > Referer——对请求中 URI 的原始获取方；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer)
  > TE——指定用户代理希望使用的传输编码类型；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/TE)
  > Upgrade-Insecure-Requests——表示客户端优先选择加密及带有身份验证的响应；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Upgrade-Insecure-Requests)
  > User-Agent——浏览器信息；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/User-Agent)

* 常见的Response Headers

  > Accept-Ranges——是否接受字节范围请求；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Ranges)
  > Age——消息对象在缓存代理中存贮的时长，以秒为单位；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Age)
  > Clear-Site-Data——表示清除当前请求网站有关的浏览器数据（cookie，存储，缓存）；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Clear-Site-Data)
  > Content-Security-Policy——允许站点管理者在指定的页面控制用户代理的资源；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy__by_cnvoid)
  > Content-Security-Policy-Report-Only—— [详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy-Report-Only)
  > ETag——资源的匹配信息；[链接描述](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag)
  > Location——令客户端重定向至指定 URI；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Location)
  > Proxy-Authenticate——代理服务器对客户端的认证信息；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Proxy-Authenticate)
  > Public-Key-Pins——包含该Web 服务器用来进行加密的 public key （公钥）信息；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Public-Key-Pins)
  > Public-Key-Pins-Report-Only——设置在公钥固定不匹配时，发送错误信息到report-uri；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Public-Key-Pins-Report-Only)
  > Referrer-Policy——用来监管哪些访问来源信息——会在 Referer 中发送；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy)
  > Server——HTTP 服务器的安装信息；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Server)
  > Set-Cookie——服务器端向客户端发送 cookie；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie)
  > Strict-Transport-Security——它告诉浏览器只能通过HTTPS访问当前资源；[详情](https://developer.mozilla.org/zh-CN/docs/Security/HTTP_Strict_Transport_Security)
  > Timing-Allow-Origin——用于指定特定站点，以允许其访问Resource Timing API提供的相关信息；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Timing-Allow-Origin)
  > Tk——显示了对相应请求的跟踪情况；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Tk)
  > Vary——服务器缓存的管理信息；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary)
  > WWW-Authenticate——定义了使用何种验证方式去获取对资源的连接；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/WWW-Authenticate)
  > X-XSS-Protection——当检测到跨站脚本攻击 (XSS)时，浏览器将停止加载页面；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-XSS-Protection)

* 自定义headers

##### http 和 https 的区别

http是超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。

HTTPS是一种**通过计算机网络**进行**安全通信**的传输协议，基于HTTP协议进行通信，利用**SSL/TLS建立安全信道**，加密数据包。HTTPS使用的主要目的是提供对**网站服务器**的**身份认证**，同时保护**交换数据**的**隐私与完整性**。

http

> 1. 无状态：议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作
>
> 2. 无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。
>
> 3. 简单、快速、灵活
>
> 4. 通信使用明文，请求和响应不会对通信方进行确认、无法保护数据的完整性

https

> 1. 内容加密：采用混合加密技术，中间者无法直接查看明文内容
> 2. 验证身份：通过证书认证客户端访问的是自己的服务器
> 3. 保护数据完整性：防止传输的内容被中间人冒充或者篡改

> http 和 https 区别
>
> * HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费
>
> * HTTP 是运行在 TCP 协议之上的，是明文传输，安全性较；HTTPS 是运行在 SSL / TLS层之上，通过 SSL \ TLS 进行了加密，安全性很高
>
> * HTTP 的端口号是 80，HTTPS 是 443

![](media\SSL协议1.jpg)

![](media\SSL协议2.jpg)

https 加密过程

![](media\https加密过程.jpg)



> 对称加密算法加密数据 + 非对称加密算法交换密钥 + 数字证书验证身份 = 安全

HTTPS 在**内容传输**的加密上使用的是**对称加密**，非对称加密只作用在证书验证阶段。

1. 为什么数据传输是用对称加密？

   >  非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的。

2. HTTPS 的传输过程是怎样的？

   >  客户端发起 HTTPS 请求，服务端返回证书，客户端对证书进行验证，验证通过后本地生成用于改造对称加密算法的随机数，通过证书中的公钥对随机数进行加密传输到服务端，服务端接收后通过私钥解密得到随机数，之后的数据交互通过对称加密算法进行加解密。

> - 对称加密: 加密和解密的秘钥使用的是同一个.
>   - 优点：算法公开、计算量小、加密速度快、加密效率高
>   - 缺点：在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。
> - 非对称加密: 与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。
>   *  公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。
>   *  优点：安全
>   *  缺点：速度较慢

3. 使用 CA 证书的原因？

> 在第一次握手的过程中，中间人完全可以截获服务端发送给客户端的公钥，并且将自己的公钥发送给客户端。客户端用中间人的公钥加密对称密钥，再将结果发送给服务端，中间人再次截获，用自己的私钥解密，获取密钥，再用服务端的公钥加密后发送给服务端。这样，中间人分别冒出服务端和客户端跟彼此交互，就可以窃取信息了。
>
> 

##### 计算机网络各层协议

1. 物理层（Physical Layer）:OSI模型的最低层或第一层，规定了激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性，为上层协议提供了一个**传输数据的物理媒体**。

2. 数据链路层（Datalink Layer）:OSI模型的第二层，它控制网络层与物理层之间的通信，其主要功能是在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。

3. 网络层（Network Layer）:OSI模型的第三层，其主要功能是将**网络地址翻译成对应的物理地址**，并决定如何将数据从发送方路由到接收方。该层的作用包括：对子网间的数据包进行路由选择，实现拥塞控制、网际互连等功能。

4. 传输层（Transport Layer）:OSI模型中最重要的一层，是第一个**端到端，即主机到主机**的层次。其主要功能是负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。

5. 会话层（Session Layer）:OSI模型的第五层，管理**主机之间的会话进程**，即负责建立、管理、终止进程之间的会话。其主要功能是建立通信链接，保持会话过程通信链接的畅通，利用在数据中插入校验点来同步两个结点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。

6. 表示层（Presentation Layer）:OSI模型的第六层，应用程序和网络之间的翻译官，负责对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括**数据的解密和加密、压缩、格式转换**等。

7. 应用层（Application Layer）:OSI模型的第七层，负责为**操作系统或网络应用程序提供访问网络服务的接口**。术语“应用层”并不是指运行在网络上的某个特别应用程序，应用层提供的服务包括文件传输、文件管理以及电子邮件的信息处理。

   

##### tcp 三次握手和四次挥手

> 三次握手：为了确认**对方**的**发送和接收**能力。

> 三次握手主要流程：
>
> 从最开始双方都处于`CLOSED`状态。然后服务端开始监听某个端口，进入了`LISTEN`状态。
>
> 然后客户端主动发起连接，发送 SYN , 自己变成了`SYN-SENT`状态。
>
> 服务端接收到，返回`SYN`和`ACK`(对应客户端发来的SYN)，自己变成了`SYN-REVD`。
>
> 之后客户端再发送`ACK`给服务端，自己变成了`ESTABLISHED`状态；服务端收到`ACK`之后，也变成了`ESTABLISHED`状态。

> 为什么需要三次握手呢？为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。
>
> client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段，但是server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求，于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了，由于client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据，但server却以为新的运输连接已经建立，并一直等待client发来数据。所以没有采用“三次握手”，这种情况下server的很多资源就白白浪费掉了。

<img src="media\三次握手.png" style="zoom:50%;" />

> 四次挥手
>
> 发送后客户端变成了`FIN-WAIT-1`状态。注意, 这时候客户端同时也变成了`half-close(半关闭)`状态，即无法向服务端发送报文，只能接收。
>
> 服务端接收后向客户端确认，变成了`CLOSED-WAIT`状态。
>
> 客户端接收到了服务端的确认，变成了`FIN-WAIT2`状态。
>
> 随后，服务端向客户端发送`FIN`，自己进入`LAST-ACK`状态，
>
> 客户端收到服务端发来的`FIN`后，自己变成了`TIME-WAIT`状态，然后发送 ACK 给服务端。

>  为什么是四次而不是三次？
>
>  如果是三次的话，那么服务端的 ACK 和 FIN 合成一个挥手，那么长时间的延迟可能让 TCP 一位 FIN 没有达到服务器端，然后让客户的不断的重发 FIN。
>
>  为什么需要四次挥手呢？TCP是全双工模式，当client发出FIN报文段时，只是表示client已经没有数据要发送了，client告诉server，它的数据已经全部发送完毕了；但是，这个时候client还是可以接受来server的数据；当server返回ACK报文段时，表示它已经知道client没有数据发送了，但是server还是可以发送数据到client的；当server也发送了FIN报文段时，这个时候就表示server也没有数据要发送了，就会告诉client，我也没有数据要发送了，如果收到client确认报文段，之后彼此就会愉快的中断这次TCP连接。

> 注意了，这个时候，客户端需要等待足够长的时间，具体来说，是 2 个 `MSL`(`Maximum Segment Lifetime，报文最大生存时间`), 在这段时间内如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。
>
> ### 等待2MSL的意义
>
> - 1 个 MSL 确保四次挥手中**主动关闭方**最后的 ACK 报文最终能达到对端
> - 1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达

<img src="media\四次挥手.png" style="zoom:50%;" />

##### 流量控制和拥塞控制

流量控制（由接收方控制发送发的速度）

* 数据链路层：停止等待协议、滑动窗口协议（单帧滑动窗口 1-1、多帧滑动窗口-后退N帧协议n-1、多帧滑动窗口-选择重传协议n-n）
* 传输层：TCP流量控制 min（接收窗口，拥塞窗口）

拥塞控制（让网络承受住现有的网络负荷（全局性））

* 慢开始和拥塞避免
  * 指数规律增大-->遇到阈值后；加法增大--> 网络拥塞； 乘法减小
* 快重传和快恢复
  * 接收方收到三个冗余 ACK ，即快重传，不用等报文段设置的重传计时器超时
  * 乘法减小时，从拥塞窗口的一般开始

##### HTTP1和HTTP2的区别

[CSDN](https://blog.csdn.net/JAVA_I_want/article/details/104648129)

>  Http1.0

1. 浏览器与服务器只保持短暂的连接，**浏览器的每次请求都需要与服务器建立一个TCP连接**（TCP连接的新建成本很高，因为需要客户端和服务器三次握手），**服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求**；

> Http1.1

1. 持久连接（**与Http1其它版本的最大区别**）引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive(对于同一个域名，大多数浏览器允许同时建立6个持久连接)

2. 虽然**允许复用TCP连接**，但是同一个TCP连接里面，所有的数据通信是**按次序进行的**。服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着。这将导致“队头堵塞”

>  Http/2.0

1. 采用**二进制格式**而非文本格式；HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”：头信息帧和数据帧。**二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少。**

2. **单一长连接**的完全**多路复用**，而非有序并阻塞的、只需一个连接即可实现并行；（**解决了线头阻塞的问题，与Http1最重要的区别**）

3. 使用**报头压缩**，降低开销

   > HTTP 协议是没有状态，导致每次请求都必须附上所有信息。所以，请求的很多头字段都是重复的，比如Cookie，一样的内容每次请求都必须附带，这会浪费很多带宽，也影响速度。
   > 对于相同的头部，不必再通过请求发送，只需发送一次；
   > HTTP/2 对这一点做了优化，引入了头信息压缩机制；
   > 一方面，头信息使用gzip或compress压缩后再发送；
   > 另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，产生一个索引号，之后就不发送同样字段了，只需发送索引号。

##### TCP 和 UDP 区别

1. TCP 是面向连接的，在传送数据之前必须先建立连接，数据传送结束后要释放连接。

   UDP 是无连接的，UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。

2. TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达；

   UDP 使用尽最大努力交付，不保证可靠交付

3. TCP 提供全双工通信， 面向字节流。

   UDP 是面向报文的

4. TCP 可以进行流量控制（滑动窗口）和拥塞控制（慢开始和拥塞避免、快重传和快恢复）；

   UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；



##### 一次完整的HTTP服务过程

> [掘金](https://juejin.cn/post/6844903989159411726)（简述）
>
> [掘金](https://juejin.cn/post/6844903815091748872)（详细 浏览器渲染网页的过程）



1. 域名解析，得到 ip 地址
2. 根据 ip 地址，找到对应的服务器，发起 TCP 三次握手
3. 简历 TCP 连接后发起 HTTP 请求
4. 服务器相应 HTTP 请求，浏览器得到 HTML 代码
5. 浏览器解析 HTML 代码
6. 浏览器对页面进行渲染
7. 四次挥手，服务器关闭连接

* DNS 是怎么找到域名的？

  > - 当客户端需要域名解析时，通过本机的DNS客户端构造一个`DNS请求报文`，以`UDP数据报`方式发往`本地域名服务器`。
  > - 域名解析有两种方式:`递归查询`和`递归与迭代`相结合的查询。
  > - 依次是：本地域名服务器、根域名服务器、顶级域名服务器、权限域名服务器
  >
  > (1) 递归方式查询：先查询本地域名服务器，找不到后，本地域名服务器向根域名服务器查询，根域名服务器向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询。
  >
  > (2) 迭代方式查询：先查询本地域名服务器，找不到后，**本地域名服务器**向根域名服务器查询，**本地域名服务器**向顶级域名服务器查询，**本地域名服务器**向权限域名服务器查询。
  >
  > [CSDN-域名解析](https://blog.csdn.net/liuchang19950703/article/details/111507464)

* 三次握手和四次挥手



当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？

```
（1）首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，
将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字
符，则对非法字符进行转义后再进行下一过程。

（2）浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新
的请求。

（3）下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果
有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域
名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地
址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用
户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。

（4）当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源
端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给
数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地
址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果
在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该
转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应
该为网关的地址。

（5）下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接
收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的
确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立
状态，此时双方的连接就建立起来了。

（6）如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版
本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证
书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后
发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解
密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加
密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。

（7）当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行
解析，开始页面的渲染过程。

（8）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端
是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建
立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页
面进行绘制。这个时候整个页面就显示出来了。

（9）最后一步是 TCP 断开连接的四次挥手过程。
```



##### GET POST 请求的详细区别

```
Post 和 Get 是 HTTP 请求的两种方法。

（1）从应用场景上来说，GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网
页。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景。比如注册用户这一类的操作。

（2）因为不同的应用场景，所以浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。

（3）从发送的报文格式来说，Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。

（4）但是 Get 请求也可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说，一个方面是不太安全，
因为请求的 url 会被保留在历史记录中。并且浏览器由于对 url 有一个长度上的限制，所以会影响 get 请求发送数据时
的长度。这个限制是浏览器规定的，并不是 RFC 规定的。还有就是 post 的参数传递支持更多的数据类型。
```



[GET POST 请求的详细区别](https://www.cnblogs.com/wuvkcyan/p/8994364.html)

前言: 作为最常见的请求方式 在面试很有可能会被问到 所以在这里做一个简单总结

> GET

- get方法向页面请求发送参数

- 地址和参数之间用?进行分割 例如 localhost:80/download.html?fileName=+"fileName"+"&filePath="+filePath

- 字符串会显示在地址栏的url上面 不安全 敏感信息 不可以用get (例如登录)

- get方法有大小限制 ,请求字符最多只能是1024字节

- get请求会被缓存

- get请求会被保存在浏览器记录里面

- get请求可以添加进书签

- get请求的编码类型为 application/x-www-from-urlencoded

- 只允许 ASCII数据类型 不允许二进制流(上传没办法使用get)

- 点击刷新 ,get请求数据不变 页面不会有变化

- get请求主要是用来获取数据

  

>  POST

- post方法想页面请发带参数
- 使用post方法时,查询字符串在post信息里面单独存在 和HTTP一起发送到服务器
- 编码类型 为application/x-www-form-urlencoded 二进制为 multipart
- 没有历史记录
- 参数类型没有限制 可以是字符串 也可以是二进制流
- 数据不会被显示在地址栏,也不会缓存下来或者保存在浏览记录里面,所以post相对get来说比较安全,但也不是最安全的方式,如传输敏感数据还要使用加密方式传输
- post传输的数据量大 可以达到2M,而get因为url长度的限制 只能是1024字节

总地来说

**POST适合将数据传送到服务器**

**GET 适合从服务器端获取数据**



## 面试

##### 1、foreach filter map reduce 

```js
var arr = [3, 5, 34, 8, 23, 5]

/* 
    forEach()
    它总是返回 undefined 值，并且不可链式调用
    除了抛出异常以外，没有办法中止或跳出 forEach() 循环。
*/

var newArr1 = arr.forEach((value, i) => {
    // value += 1 // [ 3, 5, 34, 8, 23, 5 ]
    arr[i] += 1;
})

console.log(arr) // [ 4, 6, 35, 9, 24, 6 ]
console.log(newArr1) // undefined
```

```js
/**
    map()
    会返回一个新数组，如果没有返回语句，那么默认返回 undefined
 */

var newArr2 = arr.map((value, i) => {
    // value += 1 // [ 3, 5, 34, 8, 23, 5 ]
    arr[i] += 1;
})

console.log(arr) // [ 4, 6, 35, 9, 24, 6 ]
console.log(newArr2) // [ undefined, undefined, undefined, undefined, undefined, undefined ]
```

```js
/**
    fileter()
    返回符合条件的元素
 */

var newArr3 = arr.filter((value, i) => {
    arr[i] += 1      
    // value += 1   // [ 3, 5, 34, 8, 23, 5 ]
    return i % 2 == 0
})

console.log(arr)	// [ 4, 6, 35, 9, 24, 6 ]
console.log(newArr3) // [ 3, 34, 23 ]
```



1. map：创建一个新数组，返回该数组中每个元素调用一次提供的函数后的返回值；

2. filter：过滤中通过指定函数测试的元素；

3. reduce：这是一个数组的归并方法,对给定的数组进行遍历，函数的第一个参数是迭代计算后结果。

   ```js
   array.reduce(function(accumulator, currentValue, currentIndex, arr), initialValue)
   // `initialValue`：传递给函数的初始值；
   ```

* 数组求和

```js
   // 和为 6
   var total = [ 0, 1, 2, 3 ].reduce(( acc, cur ) => acc + cur,0);
```

* 对象求和

```js
   // logs 6
   var initialValue = 0;
   var sum = [{x: 1}, {x:2}, {x:3}].reduce(function (accumulator, currentValue) {
       return accumulator + currentValue.x;
   },initialValue)
   
   console.log(sum)
```

* 二维数组转成一维数组

```js
   var flattened = [[0, 1], [2, 3], [4, 5]].reduce(
     function(a, b) {
       return a.concat(b);
     },
     []);
   // flattened is [0, 1, 2, 3, 4, 5]
```



**例子：**

```js
var arr = [1, 3, 6, 9, 15, 19, 16];

// 1、产生一个每个元素都比原来大10的新数组
var newArr1 = arr.map((val, index) => val + 10)

// 2、得到所有奇数的和
var newArr2 = arr.reduce((acc, curr) => acc + (curr % 2 === 1 ? curr : 0), 0)

// 3、得到值大于8且下标是偶数的元素组成的数组
var newArr3 = arr.filter((val, index) => (index % 2 === 0) && val > 8)

// 4、找出一个值大于8且下标是偶数位的数(注意：是一个)
var newArr4 = arr.find((val, index) => val > 8 && (index % 2 === 0));

// 5、找出一个值大于8且下标是偶数位的数的下标(注意：是一个)
var index = arr.findIndex((val, index) => val > 8 && (index % 2 === 0));
```

4. every
5. some

```js
// every()是对数组中每一项运行给定函数,如果该函数对每一项返回true,则返回true。
// some()是对数组中每一项运行给定函数,如果该函数对任一项返回true,则返回true。
var arr = [ 1, 2, 3, 4, 5, 6 ]; 

console.log( arr.every( function( item, index, array ){ 
    console.log( 'item=' + item + ',index='+index+',array='+array ); 
    return item > 3; 
}));
/*
item=1,index=0,array=1,2,3,4,5,6
false
*/

console.log( arr.some( function( item, index, array ){ 
    console.log( 'item=' + item + ',index='+index+',array='+array ); 
    return item > 3; 
})); 
/*
item=1,index=0,array=1,2,3,4,5,6
item=2,index=1,array=1,2,3,4,5,6
item=3,index=2,array=1,2,3,4,5,6
item=4,index=3,array=1,2,3,4,5,6
true
*/
```





##### 3、求嵌套对象深度



**注意**

call 的性能要比 apply 要好一些，尤其传递给函数参数超过三个的时候。

```js
let arr = [10, 20, 30]

function fn(x, y, z) {
    console.log(x = `${x}`)
    console.log(x = `${y}`)
    console.log(x = `${z}`)
}
var obj = {}

console.log(fn.apply(obj, arr)) // => x=10, y=20, z=30
console.log(fn.call(obj, arr)) // => x=[10, 20, 30], y=z=undefined
console.log(fn.call(obj, ...arr)) // => x=10, y=20, z=30
```







##### 12、addEventListener和onclick的区别

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <ul id="color-list">
        <li id="addEvent">red</li>
        <li id="on_click">yellow</li>
    </ul>
    <script type="text/javascript">
        (function() {
            var addEvent = document.getElementById("addEvent");
            addEvent.addEventListener("click", function() {
                alert("我是addEvent1");
            }, false);
            addEvent.addEventListener("click", function() {
                alert("我是addEvent2");
            }, false);

            var addEvent = document.getElementById("on_click");

            on_click.onclick = function() {
                alert("我是click1");
            }
            on_click.onclick = function() {
                alert("我是click2");
            }
        })();
    </script>
</body>

</html>
```

> 点击第一个，两个事件都会触发
>
> 点击第二个，之后最后一个才会有效。



##### 13、currentTarget VS target

1. target：触发事件的元素。
   currentTarget：事件绑定的元素。
2. 两者在没有冒泡的情况下，是一样的值，但在用了事件委托的情况下，就不一样了；
3. currentTarget始终是监听事件者，而target是事件的真正发出者。



##### 15、手写数组去重

```js
var arr = [1, 3, 5, 2, 4, 2, 1, 5, 8]

function fn(arr) {
    let set = new Set(arr);
    return [...set];
}

function del(arr) {
    let result = [];
    for (let i = 0; i < arr.length; i++) {
        if (result.indexOf(arr[i]) == -1) {
            result.push(arr[i]);
        }
    }
    return result;
}

console.log(del(arr))		// [ 1, 3, 5, 2, 4, 8 ]
console.log(fn(arr))		// [ 1, 3, 5, 2, 4, 8 ]
```

##### 16、数组扁平化

```js
/* ES6 */
const flatten = (arr) => {
  let result = [];
  arr.forEach((item, i, arr) => {
    if (Array.isArray(item)) {
      result = result.concat(flatten(item));
    } else {
      result.push(arr[i])
    }
  })
  return result;
};

const arr = [1, [2, [3, 4]]];
console.log(flatten(arr));

// 自己定义
function flatFn(arr) {
    let res = []
    arr.forEach(value => {
        if (Array.isArray(value)) {
            res = res.concat(flatFn(value))
        } else {
            res.push(value)
        }
    })
    return res
}
```

##### 17、懒加载

[懒加载](https://juejin.cn/post/6844903574883794951)

**优点**：

1、能提升用户的体验，不妨设想下，用户打开像手机淘宝长页面的时候，如果页面上所有的图片都需要加载，由于图片数目较大，等待时间很长，用户难免会心生抱怨，这就严重影响用户体验。

2、减少无效资源的加载，这样能明显减少了服务器的压力和流量，也能够减小浏览器的负担。

3、防止并发加载的资源过多会阻塞js的加载，影响网站的正常使用。



**原理**：首先将页面上的图片的 **src 属性设为空字符串**，而图片的真实路径则设置在**`data-original`**属性中， 当页面滚动的时候需要去**监听scroll事件**，在scroll事件的回调中，判断我们的懒加载的图片是否进入可视区域,如果图片在可视区内**将图片的 src 属性设置为data-original 的值**，这样就可以实现延迟加载。



##### 20、axios实现原理

[https://blog.csdn.net/luchuanqi67/article/details/81329358](https://blog.csdn.net/luchuanqi67/article/details/81329358)

1. axios 原理还是属于 XMLHttpRequest， 因此需要实现一个ajax。 
2. 还需要但会一个promise对象来对结果进行处理。







## vue常见面试题

##### 1、对 MVVM 的理解？

软件架构设计模式

```
传统的 MVC 指的是,用户操作会请求服务端路由，路由会调用对应的控制器来处理,控制器会获取数据。将结果返回给前端,页面重新渲染。
MVVM :传统的前端会将数据手动渲染到页面上,MVVM模式不需要用户手动操作dom元素，将数据绑定到 viewModel 层上，会自动将数据渲染到页面中，视图变化会通知 viemodel 层更新数据。viemodel 就是我们MVVM模式中的桥梁。
```

> Model层仅仅关注数据本身，这里可以把它理解为一个类似json的数据对象。View层通过使用模板语法来声明式的将数据渲染进DOM。ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中
>
> 在 MVVM 中，不需要手动地同步View和Model，View 是通过数据驱动的，Model一旦改变就会相应的刷新对应的 View，View 如果改变，也会改变对应的Model。这种方式就可以在业务处理中只**关心数据的流转**，而无需直接和页面打交道。
>
> 在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。



##### 2、vue2.x 的响应式数据原理？

> vue响应式原理：（数据劫持、依赖收集、派发更新）
>
> 初始化Vue实例时，Observer遍历data里所有属性，使用Object.defineProperty()方法把这些属性都转为getter/setter。并且创建dep管理器（一个属性一个Dep，用来管理该属性下的所有Watcher，如果同一个属性在DOM节点中多次使用会创建多个Watcher）
>
> 在解析指令时，创建Watcher，将更新函数放到Watcher的回调上。
>
> 初始化视图时，会读取属性值，触发get，将创建的Watcher添加到dep中。
>
> 当修改数据时，触发set，调用dep的notify，通知该dep内部所有Watcher的执行回调，重新render当前组件，生成新的虚拟DOM树。
>
> Vue框架会遍历并对比新虚拟DOM树和旧虚拟DOM树种每个节点的差别，并记录下来，最后，加载操作，将所有记录的不同点，局部修改到真DOM树上。

响应式原理整理的不错的文章：

[尚硅谷下面的评论整理](https://juejin.cn/post/6932659815424458760#heading-2)

[CSDN自己发现的博客](https://blog.csdn.net/wangweianger/article/details/79826801?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-79826801.pc_agg_new_rank&utm_term=dep%E5%92%8Cwatch+vue&spm=1000.2123.3001.4430)



[Vue响应式系统技术原理和Vue3响应式系统的优点](https://juejin.cn/post/6844904021619113992#heading-0) 挺不错~

[Vue的MVVM实现原理 - 仿写源码](https://juejin.cn/post/6844904183938678798#heading-10)   [github中的源码](https://github.com/young508/Mvue)



观察者模式、依赖收集、派发更新

**1、observe 函数和 defineReactive 函数**

目的：把**目标对象属性**转换成**访问器属性**

> observer 函数

首先new了一个依赖收集器，这个dep的作用是，当目标对象增删属性时，通知对目标对象“感兴趣”的观察者；

最后遍历对象属性，并执行defineReactive函数。

> defineReactive函数

创建了一个dep实例，这个dep 在访问器属性的 getter/setter 中被闭包引用，这个dep的作用是当目标对象属性发生写操作时，通知“感兴趣”的观察者

如果属性是对象或者数组，则调用observe函数并把这个属性当做实参，目的是使目标对象深度可侦测；

使用Object.defineProperty函数把目标对象属性转成访问器属性，在getter方法里，通过执行dep.depend方法，收集对当前属性“感兴趣”的观察者；在setter方法里，执行observe(newVal)，把新增加的属性值变成可侦测的，并执行dep.notify()，通知对此属性“感兴趣”的所有观察者。



**对对象属性进行增删操作的拦截**

Object.defineProperty并不能拦截对象增删属性，Vue是通过Vue.set和Vue.delete实现对象增删属性拦截的。set方法里，首先将新加的属性设置为访问器属性，使其变为响应式，然后调用target.__ob__.dep.notify方法，通知观察者。del方法里，首先将属性从对象里删除，然后调用target.__ob__.dep.notify方法，通知观察者。



**对数组操作的拦截**

数组的侦测，首先重写数组的原型为arrayMethods；然后遍历数组，对每一个元素调用observe函数。何为arrayMethods？首先设置arrayMethods的原型为Array.prototype；然后往arrayMethods上定义7个属性，这7个属性其实是重写的7个数组变异方法。有的数组变异方法是可以新增元素的，要把新增加的元素变成响应式的；在所有的变异方法里都会调用数组的__ob__.dep.notify方法通知观察者。



**Vue2可以拦截的数据变更：**

* 对象属性的写操作；

* 非根级响应式对象的增删属性操作；

* 数组7个变异方法的拦截。

  

 **Vue2不能拦截的数据变更：**

* Vue 不允许动态添加**根级响应式属性**，所以你必须在初始化实例前声明所有根级响应式属性；

* 使用array[index] = item方式给**数组元素赋值**；

* 使用array.length = newLength方式**改变数组长度**。



##### 3、Vue3相比Vue2在响应式系统方面的提升

* Vue3的数据劫持是通过Proxy实现的，而Vue2是通过Object.defineProperty实现的
* Vue3支持Object、Array、Map、WeakMap、Set、WeakSet六种数据类型的数据劫持，而Vue2只支持Object、Array两种数据类型；并且Vue3可以劫持对象的属性增删和数组的索引操作。
  

##### 4、Object.defineProperty 和 proxy 对比

1、`Object.defineProperty`无法监听数组变化。`vm.items[indexOfItem] = newValue`这种是无法检测的。

2、`Object.defineProperty`的第二个缺陷,只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。



1、我们可以看到,Proxy直接可以劫持整个对象,并返回一个新对象,不管是操作便利程度还是底层功能上都远强于`Object.defineProperty`。

2、Proxy可以直接监听数组的变化

3、Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是`Object.defineProperty`不具备的。

4、Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而`Object.defineProperty`只能遍历对象属性直接修改。



##### 5、vue里面为什么要进行异步渲染

Vue 异步执行 DOM 更新。只要**观察到数据变化**，Vue 将**开启一个队列**，并**缓冲在**同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。

现在有这样的一种情况，mounted的时候test的值会被++循环执行1000次。 每次++时，都会根据响应式触发`setter->Dep->Watcher->update->run`。 如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。 所以Vue实现了一个`queue`队列，在下一个Tick（或者是当前Tick的微任务阶段）的时候会统一执行`queue`中`Watcher`的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。 保证更新视图操作DOM的动作是在当前栈执行完以后下一个Tick（或者是当前Tick的微任务阶段）的时候调用，大大优化了性能。

```
   因为不采用异步更新，在每次更新数据都会对当前组件进行重新渲染。所以为了性能考虑，vue 会在本轮数据更新后，再去异步更新视图。
    vue是组件级更新，当前组件里的数据变了，它就会去更新这个组件。当数据更改一次组件就要重新渲染一次，性能不高，为了防止数据一更新就更新组件，所以做了个异步更新渲染。（核心的方法就是nextTick）
原理：
	当数据变化后会调用notify方法，将watcher遍历，调用update方法通知watcher进行更新，这时候watcher并不会立即去执行，在update中会调用queueWatcher方法将watcher放到了一个队列里，在queueWatcher会根据watcher的进行去重，多个属性依赖一个watcher，如果队列中没有该watcher就会将该watcher添加到队列中，然后通过nextTick异步执行flushSchedulerQueue方法刷新watcher队列。flushSchedulerQueue中开始会触发一个before的方法，其实就是beforeUpdate，然后watcher.run() 才开始真正执行watcher，执行完
```



##### 6、vue中computer和watch之间有什么区别？

**computed是计算属性**，事实上和和data对象里的数据属性是同一类的（使用上）。

1. **支持缓存**，只有依赖数据发生改变，才会重新进行计算
2. **不支持异步**，当computed内有异步操作时无效，无法监听数据的变化
3. computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过的数据通过计算得到的
4. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed
5. 如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。

**watch是侦听属性**

1. **不支持缓存**，数据变，直接会触发相应的操作；
2. **watch支持异步**；
3. 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；
4. 当一个属性发生变化时，需要执行对应的操作；一对多；

[watch 的 immediate 属性和 deep 属性](https://blog.csdn.net/wandoumm/article/details/80259908)



##### 7、生命周期

![](media\生命周期.jpg)



##### 常用的钩子函数

| **创建阶段** |                                                              |
| ------------ | ------------------------------------------------------------ |
| beforeCreate | 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。 |
| created      | 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据监视(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 |
| beforeMount  | 在挂载开始之前被调用相关的 render 函数首次被调用.<br />此函数在执行的时候，模板已经在内存中编译好了，但是还没有挂载到页面上 |
| mounted      | el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩。 这一步，将内存中编译好的模板，真实的替换到浏览器的页面中去。<br />如果要通过某些插件操作页面上的 DOM 节点，最早要在 mounted 种进行 |

- `beforeCreate` 执行时：`data`、`el` 和 `methods`均未初始化，值为`undefined`

- `created` 执行时：`Vue` 实例观察的数据对象 `data` 已经配置好，已经可以得到`app.message`的值。`methods方法`也被初始化好了，但 `Vue` 实例使用的根 `DOM` 元素`el`还未初始化。

  > **如果要调用 methods 中的方法，或者要操作 data 中的数据，最早只能够在 created 中操作。**

  


| **运行阶段** |                                                              |
| ------------ | ------------------------------------------------------------ |
| beforeUpdate | 此时，我们的**页面还没有更新，数据已经被更新了**，在数据更新时调用，发生在虚拟DOM打补丁之前。<br />页面上数据是旧的，但是数据已经被更新了，页面尚未和最新数据保持同步。 |
| updated      | 由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。 页面上数据已经替换成最新的 |

* `beforeMount` 执行时：`data` 和 `el`均已经初始化，但从`{{message}}` 的展示情况可以看出此时 `el` 并没有渲染数据，这里就是应用的 `Virtual DOM`（虚拟Dom）技术，先把坑占住了。到后面 `mounted` 挂载的时候再把值渲染上去

* `mounted` 执行时：此时 el 已经渲染完成并挂载到实例上

  > **如果要通过某些插件操作页面上的 DOM 节点，最早要在 mounted 种进行** 

| **销毁阶段**  |                  |
| ------------- | ---------------- |
| beforeDestroy | 实例销毁之前调用 |
| destroyed     | 实例销毁后调用   |

##### Vue 的父组件和子组件生命周期钩子函数执行顺序？

Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：

- 加载渲染过程

  父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted

- 子组件更新过程

  父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated

- 父组件更新过程

  父 beforeUpdate -> 父 updated

- 销毁过程

  父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed

  

##### 在哪个生命周期内调用异步请求？

可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：

- 能更快获取到服务端数据，减少页面 loading 时间；
- ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；

![](media\生命周期2.png)



##### 8、v-if v-show

1.`v-if`在条件切换时，会对标签进行适当的创建和销毁，而`v-show`则仅在初始化时加载一次，因此`v-if`的开销相对来说会比`v-show`大。
 2.`v-if`是惰性的，只有当条件为真时才会真正渲染标签；如果初始条件不为真，则`v-if`不会去渲染标签。`v-show`则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的CSS切换。



##### 9、v-for 和 v-if 不能连用的原因？

v-for 会比 v-if优**先执行**，当一个标签上面同时存在：`v-for` 和 `v-if` 的时候，会先执行v-for循环，

然后去看循环出来的每个div上面flag的值，是真还是假。如果flag为true，就显示 ，否则就不显示

这样就造成了不必要的`性能浪费`



##### 10、为什么使用v-for时必须添加唯一的key?

**使用`v-for`更新已渲染的元素列表时,默认用`就地复用`策略**

​		列表数据修改的时候,他会根据key值去判断某个值是否修改,如果修改,则重新渲染这一项,否则复用之前的元素; 我们在使用的使用经常会使用`index`(即数组的下标)来作为`key`,但其实这是**不推荐**的一种使用方法；key的作用主要是为了高效的更新虚拟DOM。



**新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。**

需要在新旧 children 的节点中**保存映射关系**，以便能够在旧 children 的节点中**找到可复用的节点**。key也就是children中节**点的唯一标识**。

```
面试题：react、vue中的key有什么作用？（key的内部原理）
1. 虚拟DOM中key的作用：
		key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 
		随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：
										
2.对比规则：
		(1).旧虚拟DOM中找到了与新虚拟DOM相同的key：
			①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！
			②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。

		(2).旧虚拟DOM中未找到与新虚拟DOM相同的key
			创建新的真实DOM，随后渲染到到页面。
												
3. 用index作为key可能会引发的问题：
		1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:
			会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低。

		2. 如果结构中还包含输入类的DOM：
			会产生错误DOM更新 ==> 界面有问题。

4. 开发中如何选择key?:
		1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。
		2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，
		使用index作为key是没有问题的。
```





[为什么使用v-for时必须添加唯一的key?](https://juejin.cn/post/6844903577215827982)



##### 11、$nextTick用过吗，有什么作用？

​		在下次 DOM 更新循环结束之后 执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。(官网解释)
 解决的问题：有些时候在改变数据后立即要对dom进行操作，此时获取到的dom仍是获取到的是数据刷新前的dom，无法满足需要，这个时候就用到了$nextTick。

```JS
Vue.component('example', {
  template: '<span>{{ message }}</span>',
  data: function () {
    return {
      message: '未更新'
    }
  },
  methods: {
    updateMessage: function () {
      this.message = '已更新'
      console.log(this.$el.textContent) // => '未更新'
      this.$nextTick(function () {
        console.log(this.$el.textContent) // => '已更新'
      })
    }
  }
})
```



##### 为什么要在mutations 里面更改数据状态？

因为state是实时更新的，mutations无法进行异步操作，而如果**直接修改state**的话是**能够异步操作**的，当你异步对state进行操作时，还没执行完，这时候如果state已经在其他地方被修改了，这样就会导致程序存在问题了。所以state要同步操作，通过mutations的方式限制了不允许异步。



##### 为什么 mutations 是同步的？



##### 组件中的data 为什么是一个函数？

一个组件被复用多次的话，也就会创建多个实例。本质上，**这些实例用的都是同一个构造函数**。如果data是对象的话，对象属于**引用类型**，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。



##### keep-alive介绍与应用

我们在平时开发中，总有部分组件没必要多次 Init,我们需要将组件进行持久化，使组件状态维持不变，在下一次展示时，也不会重新init
，所以在vue中我们可以使用keepalive来进行组件缓存。

keep-alive是一个抽象组件：它自身不会渲染一个DOM元素，也不会出现在父组件链中；使用keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。

```js
<keep-alive :include="whiteList" :exclude="blackList" :max="amount">
    <router-view></router-view>
</keep-alive>
```

**include**定义缓存白名单，keep-alive会缓存命中的组件；**exclude**定义缓存黑名单，被命中的组件将不会被缓存；**max**定义缓存组件上限，超出上限使用LRU的策略置换缓存数据。

上面提到被keepalive包含的组件不会被再次init，也就意味着不会重新走生命周期函数，但是平时工作中很多业务场景是希望我们缓存的组件在再次渲染时能做一些事情，vue为keepalive提供了两个额外的hook,

- activated 当keepalive包含的组件再次渲染的时候触发
- deactived 当keepalive包含的组件销毁的时候触发



##### Vue父传子、子传父、兄弟之间通信

父传子、子传父、兄弟组件之间的传值 https://cn.vuejs.org/v2/guide/components-props.html https://www.jianshu.com/p/af9cb05bfbaf https://www.cnblogs.com/chen-yi-yi/p/11152391.html

##### 父子之间通信

1. 一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===> 父组件</strong>

2. 使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。

3. 绑定自定义事件：

   1. 第一种方式，在父组件中：```<Demo @atguigu="test"/>```  或 ```<Demo v-on:atguigu="test"/>```

   2. 第二种方式，在父组件中：

      ```js
      <Demo ref="demo"/>
      ......
      mounted(){
         this.$refs.xxx.$on('atguigu',this.test)
      }
      ```

   3. 若想让自定义事件只能触发一次，可以使用```once```修饰符，或```$once```方法。

4. 触发自定义事件：```this.$emit('atguigu',数据)```		

5. 解绑自定义事件```this.$off('atguigu')```

6. 组件上也可以绑定原生DOM事件，需要使用```native```修饰符。（否则的话，他会把 click 当作自定义事件）

   ```
   // 在父组件中调用子组件
   <Student ref="student" @click.native="show"/>
   ```

7. 注意：通过```this.$refs.xxx.$on('atguigu',回调函数)```绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！

##### 全局事件总线（GlobalEventBus）

1. 一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。

2. 安装全局事件总线：

   ```js
   new Vue({
   	......
   	beforeCreate() {
   		Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm
   	},
       ......
   }) 
   ```

3. 使用事件总线：

   1. 接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span>

      ```js
      methods(){
        demo(data){......}
      }
      ......
      mounted() {
        this.$bus.$on('xxxx',this.demo)
      }
      ```

   2. 提供数据：```this.$bus.$emit('xxxx',数据)```

4. 最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。

#### vue 响应式

```vue
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<title>总结数据监视</title>
		<style>
			button{
				margin-top: 10px;
			}
		</style>
		<!-- 引入Vue -->
		<script type="text/javascript" src="../js/vue.js"></script>
	</head>
	<body>
		<!--（总结 5 - 9）
			Vue监视数据的原理：
				1. vue会监视data中所有层次的数据。

				2. 如何监测对象中的数据？
								通过setter实现监视，且要在new Vue时就传入要监测的数据。
									(1).对象中后追加的属性，Vue默认不做响应式处理
									(2).如需给后添加的属性做响应式，请使用如下API：
													Vue.set(target，propertyName/index，value) 或 
													vm.$set(target，propertyName/index，value)

				3. 如何监测数组中的数据？
									通过包裹数组更新元素的方法实现，本质就是做了两件事：
										(1).调用原生对应的方法对数组进行更新。
										(2).重新解析模板，进而更新页面。

				4.在Vue修改数组中的某个元素一定要用如下方法：
							1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()
							2.Vue.set() 或 vm.$set()
				
				特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象（比如 data） 添加属性！！！

				总结：1、对于对象，vue可以检测到对象值的改变（直接更改值是可以的），但是不能够在后期给对象增加属性，这样是检测不到的。如果要增加，应该使用Vue.set() 和 vm.$set()
					  2、对于数组，不能够使用赋值的形式来更改数组的值，应该使用vue重写的的七种方法，或者Vue.set() 或 vm.$set()。
					  3、如果数组里面存储的是对象，那么可以使用赋值方式更改对象的属性。参照第一条。
		-->
		<!-- 准备好一个容器-->
		<div id="root">
			<h1>学生信息</h1>
			<button @click="student.age++">年龄+1岁</button> <br/>
			<button @click="addSex">添加性别属性，默认值：男</button> <br/>
			<button @click="student.sex = '未知' ">修改性别</button> <br/>
			<button @click="addFriend">在列表首位添加一个朋友</button> <br/>
			<button @click="updateFirstFriendName">修改第一个朋友的名字为：张三</button> <br/>
			<button @click="addHobby">添加一个爱好</button> <br/>
			<button @click="updateHobby">修改第一个爱好为：开车</button> <br/>
			<button @click="removeSmoke">过滤掉爱好中的抽烟</button> <br/>
			<h3>姓名：{{student.name}}</h3>
			<h3>年龄：{{student.age}}</h3>
			<h3 v-if="student.sex">性别：{{student.sex}}</h3>
			<h3>爱好：</h3>
			<ul>
				<li v-for="(h,index) in student.hobby" :key="index">
					{{h}}
				</li>
			</ul>
			<h3>朋友们：</h3>
			<ul>
				<li v-for="(f,index) in student.friends" :key="index">
					{{f.name}}--{{f.age}}
				</li>
			</ul>
		</div>
	</body>

	<script type="text/javascript">
		Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。

		const vm = new Vue({
			el:'#root',
			data:{
				student:{
					name:'tom',
					age:18,
					hobby:['抽烟','喝酒','烫头'],
					friends:[
						{name:'jerry',age:35},
						{name:'tony',age:36}
					]
				}
			},
			methods: {
				addSex(){
					// Vue.set(this.student,'sex','男')
					this.$set(this.student,'sex','男')
				},
				addFriend(){
					this.student.friends.unshift({name:'jack',age:70})
				},
				updateFirstFriendName(){
					this.student.friends[0].name = '张三'
				},
				addHobby(){
					this.student.hobby.push('学习')
				},
				updateHobby(){
					// this.student.hobby.splice(0,1,'开车')
					// Vue.set(this.student.hobby,0,'开车')
					this.$set(this.student.hobby,0,'开车')
				},
				removeSmoke(){
					this.student.hobby = this.student.hobby.filter((h)=>{
						return h !== '抽烟'
					})
				}
			}
		})
	</script>
</html>
```



## 常用API

字符串和数组的互相转化

```
1、数组中 toString() 方法能够把每个元素转换为字符串，然后以逗号连接输出显示。

var a = [1,2,3,4,5,6,7,8,9,0];  //定义数组
var s = a.toString();  //把数组转换为字符串
console.log(s);  //返回字符串“1,2,3,4,5,6,7,8,9,0”
console.log(typeof s);  //返回字符串string，说明是字符串类型

join() 方法可以把数组转换为字符串，不过它可以指定分隔符。在调用 join() 方法时，可以传递一个参数作为分隔符来连接每个元素。如果省略参数，默认使用逗号作为分隔符，这时与 toString() 方法转换操作效果相同。
var a = [1,2,3,4,5];  //定义数组
var s = a.join("==");  //指定分隔符
console.log(s);  //返回字符串“1==2==3==4==5”

下面使用 split() 方法把字符串转换为数组。
split() 方法是 String 对象方法，与 join() 方法操作正好相反。该方法可以指定两个参数，第 1 个参数为分隔符，指定从哪儿进行分隔的标记；第 2 个参数指定要返回数组的长度。
var s = "1==2== 3==4 ==5";
var a = s.split("==");
console.log(a);
console.log(a.constructor == Array);
```

JS 的除法和 Java 是不一样的

可以使用 Math.floor 来向下取整，达到一样的效果

```JS
var a = 123
var b = a / 10
var c = a % 10

console.log(b)              //12.3
console.log(Math.floor(b))  // 12
console.log(c)              // 3
```





String.prototype.indexOf方法用来返回一个字符串在另一个字符串中的位置，如果没找到那就返回 -1 

ES6 includes 方法:当包含时返回true，不包含时返回false，代码实例如下：

```js
var string = "foo";
var substring1 = "oo";
var substring2 = "oq";
string.includes(substring1); //true
string.includes(substring2); //false
```





js中字符串转数字的方法

1.当字符串中是纯数字

例如：var s = '234';

　　　/********** 字符串在运算操作中会被当做数字类型来处理 ***************/　

　　　s *= 1;  

　　　/******* string的两个转换函数，只对string有效 ********/

　　　 parseInt(s); // 234

　　　 parseFloat(s); //234

　　　/************ 强制类型转换 *********************/

　　　 Number(s); // 234



2.当字符串是数字加字母等非数字

例如： var s = '234string';

　　　parseInt(s);　//234

　　　parseFloat(s);  //234.0



在 js 中 ，数组是允许超过下标的

```Js
var arr = [1, 4, 5]
console.log(arr[4])	// undefined
```

