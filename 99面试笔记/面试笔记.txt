





\# 面试题
\## CSS
\### 1.一个盒子垂直水平居中有哪些方法？（2~3种方法）
space-bettewn属性
\### 2.flex怎么使用，flex:1代表了什么（三个属性）
\### 3.使用自适应布局的时候用rem,为什么可以实现自适应布局，在不同的手机端表现得是什么
rem是基于html的字体大小来进行布局的（问：不同的移动端是有不同的html字体大小吗，在拿到设计图是怎么计算的）除以16px(问：16px是基于什么来的)
\## 4.http计算机基础相关
三次握手四次挥手
常见状态码
\## vue
axios的底层是怎么实现的，用什么实现的（配套AJAX问题）
\### 5.vue的生命周期
mounted和created的区别：
created的时候，他的html的节点都没有渲染出来
mounted的时候，可以进行数据请求，进行数据绑定（此时HTML的结构已经出来了，可以将数据绑定到DOM结构上）
\### 6.组件传值分为（父传子、子传父、兄弟组件之间传值）
\### 7.keep-alive是怎么使用的
缓存、会多出来几个生命周期
\### 8.VUE双向绑定的原理
数据劫持objectDefinePropoty
数据劫持之后，通过发布订阅模式
\## JS
\###9.跨域是有哪几种方式实现的（什么是跨域，限制了什么，不同源的话会进行什么策略）
跨域的方式有：jsonP、nigix的代理、websocket以及php端修改header。
代理设置了location的哪一项？
websocket是怎么进行跨域的？
php修改header为很么修改了就想能跨域了？
\### 10.this指向
普通函数和箭头函数的this，以及怎么改变普通函数里的this指向
\### 11.apply、call、bind,区别
apply怎样实现bind
\## ES6
\### 12.promise和async await有什么区别
await有什么特点
这两个方法报错了怎么抓取
\### 13.ES6的新特性有哪些
promise async await class继承、解构赋值
定义const、var、let、箭头函数
\### 14.let、var、const的区别
const定义的对象是可以改变的（定义的是指向对象的地址）



css
\1. 一个盒子垂直水平居中有哪些方法

https://www.cnblogs.com/gzy-tw/p/11205854.html

\2. flex:1 是什么意思

https://www.runoob.com/cssref/css3-pr-flex.html

\3. rem为什么可以实现自适应布局

https://blog.csdn.net/qq_42707446/article/details/93200711

> em：基于父级元素的字体大小；
>
> rem：基于html的字体大小
>
> 由于浏览器的字体大小一般默认是16px；1rem=16px;

http
\1. 三次握手和四次挥手

https://www.pianshen.com/article/8384298792/

\2. 常见状态码

301和302的区别 https://blog.csdn.net/banana960531/article/details/85621865

\3. http的8种请求方式及区别

Vue
\1. axios底层是怎么实现的

https://blog.csdn.net/luchuanqi67/article/details/81329358 https://www.jianshu.com/p/8bc48f8fde75

\2. Vue的生命周期

created和mounted的区别

https://cn.vuejs.org/v2/guide/instance.html

\3. Vue之间父子组件传值

父传子、子传父、兄弟组件之间的传值 https://cn.vuejs.org/v2/guide/components-props.html https://www.jianshu.com/p/af9cb05bfbaf https://www.cnblogs.com/chen-yi-yi/p/11152391.html

\4. keep-alive的作用

https://www.jianshu.com/p/9523bb439950

\5. Vue的双向绑定原理

https://www.jianshu.com/p/78b31df97b70





# 前端归纳总结

1. typeof 能够判断哪些类型？
2. == 和 === 有什么区别？
3. window.onload 和 DOMContentLoaded 的区别？
4. 创建10个<a>标签， 点击的时候弹出相应的序号
5. 手写字节流throttle、防抖debounce
6. Promise解决了什么问题



解答：

1. typeof 运算符返回一个用来表示表达式的数据类型的字符串。 
   可能的字符串有："number"、"string"、"boolean"、"object"、"function" 和 "undefined"。 常用返回值说明

| 表达式                 | 返回值      |
| ---------------------- | ----------- |
| typeof undefined       | 'undefined' |
| typeof null            | 'object'    |
| typeof true            | 'boolean'   |
| typeof 123             | 'number'    |
| typeof "abc"           | 'string'    |
| typeof function() {}   | 'function'  |
| typeof {}              | 'object'    |
| typeof []              | 'object'    |
| typeof unknownVariable | 'undefined' |

### HTML

#### 何如理解HTML标签语义化？

> 让人更加容易读懂
>
> 让搜索引擎更容易读懂



#### 块级元素，行内标签，行内块元素

> 块级标签：<h1>~<h6>、<p>、<div>、<ul>、<ol>、<li>
>
> 行内元素：<a>、<strong>、<b>、<em>、<i>、<del>、<s>、<ins>、<u>、<span>
>
> 行内块元素：<img />、<input />、<td>



#### 浏览器内核

```
Trident：这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多
网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微
软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等
安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。

Gecko：这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩
展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。

Presto：Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的
天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。

Webkit：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trid
ent，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 
前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。

Blink：谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 B
link 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是
KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 
内核，加入 Google 阵营，跟随谷歌一起研发 Blink。
```

因为浏览器太多啦， 但是现在主要流行的就是下面几个：

| 浏览器  |      内核      | 备注                                                         |
| :------ | :------------: | :----------------------------------------------------------- |
| IE      |    Trident     | IE、猎豹安全、360极速浏览器、百度浏览器                      |
| firefox |     Gecko      | 可惜这几年已经没落了，打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。 |
| Safari  |     webkit     | 现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了）。苹果感觉像被别人抢了媳妇，都哭晕再厕所里面了。 |
| chrome  | Chromium/Blink | 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用Blink内核。二次开发 |
| Opera   |     blink      | 现在跟随chrome用blink内核。                                  |

**拓展阅读：**

```
移动端的浏览器内核主要说的是系统内置浏览器的内核。

Android手机而言，使用率最高的就是Webkit内核，大部分国产浏览器宣称的自己的内核，基本上也是属于webkit二次开发。

iOS以及WP7平台上，由于系统原因，系统大部分自带浏览器内核，一般是Safari或者IE内核Trident的
```



####  async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）

```
（1）脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执
     行。

 （2）defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。
     当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。

 （3）async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执
     行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。
```

![](D:\Document\00_Notes\面试笔记\media\js、html执行顺序.png)

### CSS

#### 1、布局

* **盒子模型的宽度计算**

  > ​		标准盒与怪异盒的区别在于他们的总宽度的计算公式不一样。
  >
  > ​		标准模式下总宽度offsiteWith=width+margin（左右）+padding（左右）border（左右）；怪异模式下总宽度width+margin（左右）（就是说width已经包含了padding和border值）。
  >
  > 标准模式下如果定义的DOCTYPE缺失，则在ie6、ie7、ie8下汇触发怪异模式。
  >
  > 当设置为box-sizing:content-box时，将采用标准模式解析计算，也是默认模式；
  >
  > 当设置为box-sizing:border-box时，将采用怪异模式解析计算；
  >
  > 

* **margin纵向重叠问题**

  > 1.相邻块元素垂直外边距的合并
  >
  > 2.嵌套块元素垂直外边距的合并（塌陷）(想要让子盒子再父盒子中往下移动一些)
  >
  > 
  >
  > 1.相邻元素的margin-top 和 margin-bottom 会发生重叠
  >
  > 2.空白内容的<p></p>标签也会发生重叠。

* **margin负值**

  > margin-top（上） margin-left（左） 设置负值，元素会向上、左移动
  >
  > margin-right（右） 设置负值，右侧元素左移，自身不受影响
  >
  > margin-bottom（下） 设置负值，下方元素上移，自身元素不受影响
  >
  > 

* **BFC理解和应用**

  > BFC block format context，块级格式化上下文
  >
  > 一块独立的渲染区域，内部元素的渲染不会影响到边界以外的元素

  创建BFC的方式

  * float 属性不为 none
  * position 为 absolute 或者 fixed
  * display 为 inline-block、table-cell、flex
  * overflow 为hidden、auto、scroll

  BFC能够结局什么问题

  > 1、边距重叠问题

  ```html
  <!DOCTYPE html>
  <html lang="en">
  
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Document</title>
  </head>
  <style>
      * {
          margin: 0;
          padding: 0;
      }
      
      div {
          width: 100px;
          height: 100px;
          background-color: skyblue;
      }
      
      .top {
          margin-bottom: 20px;
      }
      
      .bottom {
          margin-top: 20px;
      }
      
      p {
          overflow: hidden;
      }
  </style>
  
  <body>
      <div class="top"></div>
      <p>
          <div class="bottom"></div>
      </p>
  </body>
  
  </html>
  ```

  > 2、盒子塌陷问题

  ```html
  <!DOCTYPE html>
  <html lang="en">
  
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Document</title>
  </head>
  <style>
      * {
          margin: 0;
          padding: 0;
      }
      
      .father {
          width: 200px;
          height: 200px;
          background-color: skyblue;
          overflow: hidden;
      }
      
      .son {
          width: 100px;
          height: 100px;
          background-color: gold;
          margin-top: 50px;
      }
  </style>
  
  <body>
      <div class="father">
          <div class="son"></div>
      </div>
  </body>
  
  </html>
  ```

  > 3、清除浮动

  > 4、清除浮动环绕文字

  

* **float布局 圣杯布局 双飞翼布局（pc浏览器）**

  > [圣杯布局和双飞翼布局的理解与思考](https://www.jianshu.com/p/81ef7e7094e8)

* **clear fix清除浮动**

  > 1、额外标签法(隔墙法)
  >
  > 2、父级添加overflow属性方法
  >
  > 3、**:after 方式为空元素额外标签法的升级版，好处是不用单独加标签了** 
  >
  > ```
  > .clearfix:after {  content: ""; display: block; height: 0; clear: both; visibility: hidden;  }   
  > 
  > .clearfix {*zoom: 1;}   /* IE6、7 专有 */
  > ```
  >
  > 
  >
  > 4、使用双伪元素清除浮动
  >
  > ```
  > .clearfix:before,.clearfix:after { 
  > content:"";
  > display:table; 
  > }
  > .clearfix:after {
  > clear:both;
  > }
  > .clearfix {
  > *zoom:1;
  > }
  > ```

* **flex布局（移动端），画骰子**

  > 设置主轴：flex-direction:row / column
  >
  > justify-content: space-around / space-between
  >
  > 设置是否换行：flex-wrap: wrap / no-wrap
  >
  > 单行：align-items: flex-start
  >
  > 多行：align-content: centent
  >
  > align-self控制子项自己在侧轴上的排列方式

#### 2、定位

* **absolute 和 relative 分别依据是什么**

  > 绝对定位：不占位置，脱标，父亲没有定位，以浏览器进行定位；
  >
  > 相对定位：占据位置，占据位置

  

* **居中对齐**

  > 水平居中：
  >
  > > inline 元素：text-align: center
  > >
  > > block元素： margin: auto
  > >
  > > absolute元素：left:50% + margin-left负值(宽度一半)
  >
  > 垂直居中：
  >
  > > inline 元素：line-heigt = 行高， vertical-align 垂直对齐
  > >
  > > block元素： 
  > >
  > > absolute元素：top:50% + margin-top负值
  > >
  > > absolute元素：left：50%，top：50%；transform(-50%, -50%)
  > >
  > > absolute元素：top,left,bottom,right = 0 + margin: auto

#### 3、图文样式

* **line-heighe继承问题**

  > 如果行高是百分数，那么先计算再继承。

#### 4、响应式

* **rem em px 对比**

  > px：绝对长度单位
  >
  > em：相对长度单位，相对于父元素
  >
  > rem：相对长度单位，相对于根元素

* **如何实现响应式**

  > media-query，根据不同屏幕宽度设置根元素font-size
  >
  > rem

* **rem的局限性**

  > rem 具有台阶性
  >
  > vh 网页视口高度1/100；vw网页视口宽度：1/100； 

* 继承

  > 

#### 5、CSS3动画

#### 6、选择器权重

```
!importent ---------------- infinity
行间样式 ------------------- 1000
id选择器 ------------------------ 100
class类选择器 | 属性选择器 | 伪类 --------- 10
标签选择器 | 伪元素 --------------- 1
通配符 ---------------------- 0
```

> CSS2 中伪类、伪元素都是以单冒号`:`表示
>
> CSS2.1 后规定伪类用单冒号表示，伪元素用双冒号`::`表示，浏览器同样接受 CSS2 时代已经存在的伪元素(:before, :after, :first-line, :first-letter 等)的单冒号写法。对于 CSS2 之后所有新增的伪元素(如::selection)，应该采用双冒号的写法。但是因为兼容性问题，大部分还是用的单冒号。



#### 7、伪类和伪元素

```
伪类的概念
1. 规范解释
伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。
2. 举例说明
当用户悬停在指定的元素时，我们可以通过 :hover 来描述这个元素的状态。虽然它和普通的 CSS 类相似，可以为已有的元素添加样式，但是它只有处于 DOM 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。

伪元素的概念
1. 规范解释
伪元素用于创建一些不在文档树中的元素，并为其添加样式。
2. 举例说明
我们可以通过 :before 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。
```

区别：

1、**伪类**是操作文档中**已有的元素**，而**伪元素**是创建了一个**文档外的元素**，两者最关键的区别就是这点。

2、伪类，首先是类的一种， 作用于标签本身（状态），伪元素首先是元素，作用于内容本身。

- `CSS` 伪类用于向某些选择器添加特殊的效果。
- `CSS` 伪元素用于将特殊的效果添加到某些选择器。

3、伪类只能使用“：”，而伪元素既可以使用“:”，也可以使用“::”





>  伪类
>
>  * 状态：
>   * :link
>   * :visited
>   * :hover
>   * activate
>   * :foucs
>  * 结构化：
>   * :first-child
>   * :last-child
>   * :nth-child
>   * :nth-of-type

> 伪元素
>
> * 单双冒号
>   * ::before / :before
>   * ::after / :after
>   * :: first-letter / :first-letter
>   * :: first-line / :first-line
> * 仅双冒号
>   * ::selection
>   * ::placeholder
>   * ::backdrop

```
::before 匹配在原始元素的实际内容之后出现的区域  

::after 匹配在原始元素的实际内容之前出现的区域 

::first-letter 匹配元素的第一个字母 

::first-line 匹配元素第一行 

::selection 匹配被选中的文本或者区域


```



### JS

#### typeof 与 ===

1. typeof 可以判断那些类型？

   * typeof 返回值有六种可能： **"number," "string," "boolean," "object," "function,"** 和 "**undefined**."以及'**symbol**'
   * **null,array,object**返回的都是**‘object’**

   > 1. 识别出所有的值类型
   >
   >    ```js
   >    // typeof 能判断所有的值类型
   >    let a;                console.log(typeof a) // undefined
   >    const a = 'string'    console.log(typeof a) // string
   >    const a = 1           console.log(typeof a) // number
   >    const a = true        console.log(typeof a) // boolean
   >    const a = Symbol('a') console.log(typeof a) // Symbol
   >    ```
   >
   > 2. 可以判断出函数（function）
   >
   >    ```js
   >    // typeof 能判断函数
   >    typeof console.log(1)    // function
   >    typeof function fn () {} // function
   >    ```
   >
   > 3. 判断是否是引用类型（不可再细分，只要是就是object）(null 是一个特殊的引用数据类型)
   >
   >    ```js
   >    // typeof 判断引用类型
   >    const a = null       typeof a //object
   >    const a = { a: 100 } typeof a // object
   >    const a = ['a']      typeof a // object
   >    ```

   > 注意！typeof（未定义变量）的结果是 undefined。

2. 何时使用 == 何时使用 === 

   ```js
   "==="叫做严格运算符，"=="叫做相等运算符。
   	严格运算符的运算规则如下:
   (1)不同类型值
   如果两个值的类型不同，直接返回false。
   (2)同一类的原始类型值
   同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。
   (3)同一类的复合类型值
   两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。
   (4)undefined和null（他们与自身严格相等）
   /*******************************************************/
   null === null // true	
   undefined === undefined // true
   null === undefined	// false
   /*******************************************************/
   	相等运算符在比较相同类型的数据时，与严格相等运算符完全一样。在比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。类型转换规则如下：
   (1)原始类型的值
   原始类型的数据会转换成数值类型再进行比较。字符串和布尔值都会转换成数值。
   (2)对象与原始类型值比较
   对象（这里指广义的对象，包括数值和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行
   比较。
   (3)undefined和null
   	undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。
   /*******************************************************/
       null == null // true	
   	undefined == undefined // true
   	null == undefined	// true
   /*******************************************************/
   (4)相等运算符的缺点
   相等运算符隐藏的类型转换，会带来一些违反直觉的结果。
       '' == '0' // false
       0 == '' // true
       0 == '0' // true
       false == 'false' // false
       false == '0' // true
       false == undefined // false
       false == null // false
       null == undefined // true
       ' \t\r\n ' == 0 // true
   /*******************************************************/
   	NaN == NaN      // false，NaN和所有值包括自己都不相等。
   /*******************************************************/
   这就是为什么建议尽量不要使用相等运算符。至于使用相等运算符会不会对后续代码造成意外影响，答案是有可能会。
    var a = undefined;
           if (!a) {
               console.log("1"); //1
           }
           var a = undefined;
           if (a == null) {
               console.log("1"); //1
           }
           var a = undefined;
           if (a === null) {
               console.log("1"); //无输出
           }
   也就是说当a为undefined时，输出的值会有变化，而在编程中对象变成undefined实在是太常见了。
   ```

   > **总结**
   >
   > 除了 == null 之外，其他都一律用 === 
   >
   > ```js
   > const obj = {x : 100};
   > if (obj.a == null) {}
   > // 相当于；
   > // if （obj.a === null || obj.a === undefined）{}
   > ```
   >
   > 

3. 值类型和引用类型的区别

4. 引用类型赋值、手写深拷贝

   > 常见引用数据类型：{x:100}; arr = [] ;const n = null; function fn() {}
   >
   > null 是一个特殊的引用类型，指针指向为空地址
   >
   > 函数是一个特殊的引用类型，但是不用于存储地址，所以没有拷贝、复制函数之说

   将引用类型赋值的时候，传递的是引用类型的地址字符串拼接

   ```js
   const a = 100 + 10;		// 110
   const b = 100 + '10';	// '10010'
   const c = true + '10';	// 'true10'
   ```

   

5. falsely 变量和 truely 变量，if条件判断中的是这个，而不是true 和 false



#### 原型和原型链

1. class 和继承
2. 类型判断 instanceof
3. 原型和原型链

#### 作用域和闭包

* 全局作用域：

> ​		全局作用域只有一个全局对象 window，创建的对象都会作为window对象的属性保存；创建的函数都做作为 window 对象的方法进行保存。
>
> 1. 函数声明和变量声明提前，但是，函数表达式不会提前！
>
> 2. 相同的函数名和var声明的变量，函数名具有更高的优先级。
> 3. 
>
> ```js
> a = 5； ==> window.a = 5;
> ```
>
> ```js
> // 情况一
> console.log(a);		// undefined
> var a = 123;
> 
> // 情况二
> console.log(a);		// 报错
> a = 123;
> ```
>
> ```js
> fn()	// fn() 函数执行
> 
> function fn() {
>     console.log("fn() 函数执行")
> }
> 
> var fn2 = function() {
>     console.log("fn() 函数执行")
> }
> ```
>
> ```js
> console.log(fn2)	// undefined
> fn2()				// 报错！undefined is not a function
> 
> function fn() {
>     console.log("fn() 函数执行")
> }
> 
> var fn2 = function() {
>     console.log("fn() 函数执行")
> }
> ```
>
> 



##### 1、this在不同场景下如何取值？

> 所以我们对其四个规则进行排序：**new绑定>显式绑定>隐式绑定>默认绑定**
>
> **同时我们可以得出一套规律：**
>
> 1. **函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。**`var bar = new foo()`
> 2. **函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。**`var bar = foo.call(obj2)`
> 3. **函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。**`var demo2= obj.foo()`
> 4. **如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。**`demo();`
>
> 

以函数形式调用，this指向window

优先级递减

> - 函数是`new`出来的，`this`指向实例
> - 函数通过call、apply、bind绑定过，`this`指向绑定的第一个参数
> - 函数在某个上下文对象中调用（隐式绑定），`this`指向上下文对象
> - 以上都不是，`this`指向全局对象

以方法形式调用，this指向调用方法对象

> 1. 作为普通函数调用		
>
> 2. 作为对象方法被调用
>
> 3. 使用call apply bind
>
> 4. class方法种调用
>
> 5. 箭头函数
>
>    > this 取什么值，是在函数**执行的时候确定**的，不是在函数定义的时候确定的



> **小结**

> **如果要判断一个运行中的this绑定，重中之重就是找到它的调用位置**，找到之后根据下面四条规则来判断this指针的绑定对象。
>
> 1.  是否由new声明绑定到指定对象。
> 2. 是否由call、apply或者bind调用。
> 3. 是否上下文调用
> 4. 默认绑定，在严格模式下为undefined，否则绑定到全局对象。
>
> ​    同时要注意有时候会触发绑定例外，需要注意甄别。在ES6的箭头函数中并不会使用上列的绑定规则，而是根据当前的词法作用域来决定this的绑定对象。简单点说，就是箭头函数会直接继承上文函数调用的this绑定。

##### 2、手写bind函数

> slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。

```js
Function.prototype.bind1 = function() {
    // 将参数解析成数组, arguments 是一个列表
    const args = Array.prototype.slice.call(arguments)

    // 获取 this (取出数组第一项，数组剩余的就是要传递的参数)
    const t = args.shift()
    const self = this // 当前函数

    // 返回一个函数
    return function() {
        // 执行原函数，并返回结果
        return self.apply(t, args)
    }
}

function fn(a, b) {
    console.log(this)
    console.log(a, b)
}
let obj = {
    name: 'haha'
}
let fn1 = fn.bind1(obj, "aaa", "ccc")
fn1()
```



##### 3、闭包在开发过程中的应用场景

> 闭包：闭包是指有权访问**另一个函数作用域**中的变量的**函数**。

两种情况：

1. 函数作为参数被传递

2. 函数作为返回值被返回

   > 闭包：**所有自由变量的查找，是在函数定义的地方向上级作用域查找，不是在执行的地方**

> 应用场景

1、为节点绑定 click 事件

```html
<body>
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
    </ul>
</body>
<script>
    // var lis = document.getElementsByTagName("li");
    // for (var i = 0; i < lis.length; i++) {
    //     lis[i].onclick = function() {
    //         console.log(i);
    //     }
    // }

    var lis = document.getElementsByTagName("li");
    for (var i = 0; i < lis.length; i++) {
        (function(i) {
            lis[i].onclick = function() {
                console.log(i)
            }
        })(i);
    }
```

2、延续局部变量的寿命

```js
var report = function(src) {
    var img = new Image();
    img.src = src;
}
report('http://xxx.com/getUserInfo');

/* 这段代码在运行时，发现在一些低版本浏览器上存在bug，会丢失部分数据上报，原因是img是report函数中的局部变量，当report函数调用结束后，img对象随即被销毁，而此时可能还没来得及发出http请求，所以此次请求就会丢失。
因此，我们使用闭包把img对象封闭起来，就可以解决数据丢失的问题：*/

var report = (function() {
    var imgs = [];
    return function(src) {
        var img = new Image();
        imgs.push(img);
        img.src = src;
    }
})()
```

3、对结果进行缓存

```js
var fn=function(){
    var sum=0;
    for(var i=0;i<arguments.length;i++){
        sum+=arguments[i];
    }
    return sum;
}
console.log(fn(1,2));//3
 
//优化版本
var fn=(function(){
    var cache={}//将结果缓存到该对象中
    return function(){
        var str=JSON.stringify(arguments);
        if(cache[str]){//判断缓存中是否存在传递过来的参数，存在直接返回结果，无需计算
            return cache[str];
        }else{//进行计算并返回结果
            var sum=0;
            for(var i=0;i<arguments.length;i++){
                sum+=arguments[i];
            }
            return cache[str]=sum;
        }
    }
})()
```



##### 4、作用域和自由变量

1. 全局作用域
2. 函数作用域
3. 块级作用域（ES6新增）

自由变量：一个变量在当前作用域没有被定义，但是被使用了，向上级作用域去找，直到找到为止，如果全局作用域都没有找到，那么会报 xx is not defined

案例：点击相应的li标签，弹出对应数字



##### *** 词法作用域

词法作用域意味着作用域是由书写代码时函数声明的位置来决定的  

##### *** 变量提升

引擎会在解释 JavaScript 代码之前首先对其进行编译。 编译阶段中的一部分工作就是找到所有的声明， 并用合适的作用域将它们关联起来  。

函数声明会被提升， 但是函数表达式却不会被提升 。

函数会首先被提升， 然后才是变量 ，所以出现同名的函数和变量，函数会覆盖变量的值。但是，出现在后面的函数声明还是可以覆盖前面的。  

> 一个普通块内部的函数声明通常会被提升到所在作用域的顶部， 这个过程不会像下面的代
> 码暗示的那样可以被条件判断所控制：  
>
> ```js
> foo(); // "b"
> var a = true;
> if (a) {
> 	function foo() { console.log("a"); }
> }
> else {
> 	function foo() { console.log("b"); }
> }
> ```
>
> 所有的声明（变量和函数） 都会被“移动” 到各自作用域的最顶端， 这个过程被称为提升 。



闭包：

在定时器、 事件监听器、Ajax 请求、 跨窗口通信、 Web Workers 或者任何其他的异步（或者同步） 任务中， 只要使
用了回调函数， 实际上就是在使用闭包！  

#### 异步和单线程

1. 同步和异步区别

2. promise

   1. 回调地狱

   2. promise

3. 前端使用异步的场景有哪些？

   1. 网络请求 
   2. 定时任务

#### JS进阶

##### 1、event loop

事件循环机制

> Javascript单线程任务被分为同步任务和异步任务.
>
> - 同步任务会**在调用栈**(也被称为执行栈) 中按照顺序等待主线程依次执行.
> - 异步任务会甩给在WebAPIs处理,处理完后有了结果后，将注册的回调函数放入**任务队列**中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。
>
> 一个循环周期就是微任务结束开启另外一个宏任务
>
> 1.执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）； 
>
> 2.全局Script代码执行完毕后，调用栈Stack会清空；
>
> 3.从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；
>
> 4.继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行； 
>
> 5.microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；
>
> 6.取出宏队列macrotask queue中位于队首的任务，放入Stack中执行； 
>
>  7.执行完毕后，调用栈Stack为空；
>
> 循环 3- 7

##### 2、promise进阶

> promise.then()返回的新 promise 的结果状态由什么决定?  （注意：在执行函数中必须指明是 resolve() 还是reject）
>
> **由 then()指定的回调函数执行的结果决定**  
>
> 1. 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常
> 2. 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值
> 3. 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果 (可以返回一个pendding的promise，重点promise链)
> 4. 如果前一个Promise对象没有返回状态（resolve或者reject），也没有抛错（throw error），也没有返回具体数值，我们则认为它返回 了一个undefined，则undefined将作为后一个Promise对象的输入，执行第一个参数方法（resolve）
>
> Promise 是 JS 中进行异步编程的新的解决方案(旧的是谁?)  ，从语法上来说: Promise 是一个构造函数，从功能上来说: promise 对象用来封装一个异步操作并可以获取其结果 。

```js
console.log(1);

setTimeout(() => {
  console.log(2);
  Promise.resolve().then(() => {
    console.log(3)
  });
});

new Promise((resolve, reject) => {
  console.log(4)
  resolve(5)
}).then((data) => {
  console.log(data);
})

setTimeout(() => {
  console.log(6);
})

console.log(7);

// 1 4 7 5 2 3 6
```

```js
console.log(1)
process.nextTick(() => {
  console.log(8)
  setTimeout(() => {
    console.log(9)
  })
})
setTimeout(() => {
  console.log(2)
  new Promise(() => {
    console.log(11)
  })
})
let promise = new Promise((resolve,reject) => {
  setTimeout(() => {
    console.log(10)
  })
  resolve()
  console.log(4)
})
fn()
console.log(3)
promise.then(() => {
  console.log(12)
})
function fn(){
  console.log(6)
}

/*
    1
    4
    6
    3
    8
    12
    2
    11
    10
    9
*/
```



##### 3、async / await

* async 函数  

1. 函数的**返回值**为 **promise 对象**
2. promise 对象的结果由 async 函数执行的返回值决定  

* await 表达式  （相当于then来用）

1. await 右侧的表达式一般为 promise 对象, 但也可以是其它的值
2. 如果表达式是 promise 对象, await 返回的是 **promise 成功的值**  
3. 如果表达式是其它值, 直接将此值作为 await 的返回值  

**注意** 

1. await 必须写在 async 函数中, 但 async 函数中可以没有 await

2. 如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try...catch 捕获处理  

##### 4、微任务/宏任务

什么是宏任务和微任务，有什么区别？

宏任务：setTimeout，setInterval，Ajax，DOM事件

微任务：promise，async/await

> 微任务比宏任务更早触发。

微任务：DOM渲染前触发，是ES6规定的

宏任务：DOM渲染后触发，是浏览器规定的

* 微任务，宏任务和DOM渲染在Event Loop的过程
  * 执行同步任务，call back清空
  * 执行当前微任务
  * 尝试dom渲染
  * 触发Even Loop

#### Web API

* 获取dom

  ```js
  // 获取特殊的元素
  const body = document.body					// 返回body对象
  const html = document.documentElement		// 返回html元素 
  ```

  

  ```js
  const div1 = document.getElementById('div1')
  const divList = document.getElementByTagName('div')		// 获取过来元素对象的集合，以伪数组的形式存储的
  const containerList = document.getElementByClassName('.container')
  const aaa = document.querySelector('.aaa')							// 根据指定选择器返回第一个元素
  const pList = document.querySelectorAll('p')			// 根据指定选择器返回
  // 后面两个选择器需要加入符号
  ```

* attribute

  ```js
  p.getAttribute('data-name')
  p.setAttribute('data-name', 'haha')
  p.removeAttribute('data-name');
  ```

* dom结构操作

  ```js
  const newP = document.createElement("newP");
  ```

#### ajax

##### 手写一个简单的ajax

* XMLHttpRequest

  ```js
  // get请求
  const xhr = new XMLHttpRequest()
  xhr.open('GET', '/api', false)
  xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
          if (xhr.status === 200) {
              alert(xhr.responseText)
          }
      }
  }
  xhr.send()
  ```

  **readyStae状态的介绍:**

  ```js
   0 － （未初始化）还没有调用send()方法
   1 － （载入）已调用send()方法，正在发送请求
   2 － （载入完成）send()方法执行完成，已经接收到全部响应内容
   3 － （交互）正在解析响应内容
   4 － （完成）响应内容解析完成，可以在客户端调用了
  ```

  

##### 跨域的常用实现方式

1. 什么是跨域

* 同源策略：ajax请求时，**浏览器要求**当前网页和 server 必须同源（浏览器的安全策略）

* 同源：**协议、域名、端口**，三者必须一致

  ```js
  // 前端：http://a.com:8080 ; server: https://b.com/api/xxx (跨域)
  // 前端：http://a.com/a; server: http://a.com/b (不跨域)
  ```

  * 注意：图片、css、js 是可以跨域的，无视同源策略、

* 跨域：所有的跨域必须经过 server 端的允许和配合，未经 server 端允许就实现跨域，说明浏览器有漏洞，危险信号！

> Question1：
>
> 出于浏览器的同源策略限制，浏览器会拒绝跨域请求。
>
> 严格的说，浏览器并不是拒绝所有的跨域请求，实际上**拒绝**的是**跨域的读操作**。浏览器的同源限制策略是这样执行的：
>
> - 通常浏览器允许进行跨域写操作（Cross-origin writes），如链接，重定向；
> - 通常浏览器允许跨域资源嵌入（Cross-origin embedding），如 img、script 标签；
> - 通常浏览器不允许跨域读操作（Cross-origin reads）。
>
> 
>
> Question2：
>
> 为什么有跨域需求?
>
> 场景 —— 工程服务化后，不同职责的服务分散在不同的工程中，往往这些工程的域名是不同的，但一个需求可能需要对应到多个服务，这时便需要调用不同服务的接口，因此会出现跨域。

2. 如何实现跨域？

   通常，最常用的跨域方式有以下三种：JSONP、CORS、postMessage。

* JSONP

  * 原理

    > 虽然因为同源策略的影响，不能通过XMLHttpRequest请求不同域上的数据（Cross-origin reads）。但是，在页面上引入不同域上的js脚本文件却是可以的（Cross-origin embedding）。因此在js文件载入完毕之后，触发回调，可以将需要的data作为参数传入。

  * 实现方式（需前后端配合）

  * 优缺点

    > 优点：兼容性好（兼容低版本IE）
    > 缺点：1.JSONP只支持GET请求； 2.XMLHttpRequest相对于JSONP有着更好的错误处理机制

* CORS（服务端支持）

  需要增加一些 HTTP 头，让服务器能声明允许的访问来源。

  Access-Control-Allow-Origin: * 表明该资源可以被任意外域访问。

  详见链接 [掘金](https://juejin.cn/post/6844903496521613320)

  **案例如下：**

  ```js
  var express = require('express')
  
  // 90端口的服务，将当前目录作为http服务
  var app = express()
  app.use(express.static(__dirname))
  app.listen(90)
  
  // 91端口的服务返回数据
  var app2 = express();
  app2.get("/", function() {
      res.send("你好")
  })
  app2.listen(91)
  ```

  ```html
  <!DOCTYPE html>
  <html lang="en">
  
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Document</title>
  </head>
  
  <body>
      <h1>Hello!!!</h1>
      <script>
          fetch("http://localhost:91/")
              .then(res => res.text())
              .then(data => alert(data))
      </script>
  </body>
  
  ```

</html>

  ```
  此时，无法正确的弹出出 “你好”，浏览器会报错。

  **解决方法一：在接口的服务端修改响应头**（CORS）
  
  ```js
  var express = require('express')
  
  // 90端口的服务，将当前目录作为http服务
  var app = express()
  app.use(express.static(__dirname))
  app.listen(90)
  
  // 91端口的服务返回数据
  var app2 = express();
  app2.get("/", function() {
      res.header("Access-Control-Allow-Origin", "*")
      res.send("你好")
  })
app2.listen(91)
  ```

  **解决方法二：**（JSONP）

  ```js
  var express = require('express')
  
  // 90端口的服务，将当前目录作为http服务
  var app = express()
  app.use(express.static(__dirname))
  app.listen(90)
  
  // 91端口的服务返回数据
  var app2 = express();
  app2.get("/", function() {
      var funcName = res.query.callback;
      res.send(funcName + "('你好')")
      // f('你好')
  })
app2.listen(91)
  ```

  ```html
  <!DOCTYPE html>
  <html lang="en">
  
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Document</title>
  </head>
  
  <body>
      <h1>Hello!!!</h1>
      <script>
          f(data) {
              alert(data)
          }
      </script>
      <script src="http://localhost:91?callback=f"></script>
  </body>
  
  </html>
  ```

##### cookie、localStorage、sessionStorage

参考链接[掘金](https://juejin.cn/post/6844903516826255373)

* cookie缺点

  * 最大存储4kb
  * 可设置失效时间，没有设置的话，默认是关闭浏览器后失效
  * http请求时需要发送到服务端，增加数据请求量
  * 只能用document.cookie = ' xxx = xxx'，来修改，有的话就覆盖，没有的话就追加

* localStorage

  > `localStorage`只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。
  >
  > ```js
  > localStorage.setItem("b","isaac");	//设置b为"isaac"
  > var b = localStorage.getItem("b");	//获取b的值,为"isaac"
  > var a = localStorage.key(0); 		// 获取第0个数据项的键名，此处即为“b”
  > localStorage.removeItem("b");		//清除c的值
  > localStorage.clear();				//清除当前域名下的所有localstorage数据
  > ```

* sessionStorage

  > sessionStorage`比`localStorage`更严苛一点，除了协议、主机名、端口外，还要求在同一**窗口**（也就是浏览器的标签页）下。

  * HTML5专门为存储而设计，最大存储5M
  * 不会随着http请求而发送出去

  作用域

  cookie、localStorage和sessionStorage 三者之间的区别

  * （1）生命周期：
    * cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效
    * localStorage数据会永久存储，除非代码或者手动删除
    * sessionStorge数据只存在于当前会话，浏览器关闭则清空
  * （2）存放数据大小：
    * cookie：4KB左右
    * localStorage和sessionStorage：可以保存5MB的信息。
  * （3）http请求
    * cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题
    * localStorage和sessionStorage：仅在客户端（即浏览器）中保存，不参与和服务器的通信

  **总结**

  1. 从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比storage更好用的。其他情况下，可以使用storage，就用storage。
  2. localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来跨页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。

  **特别注意：**

  `服务端的session，和前端的sessionStorage是两个东西,session才是存放在服务端，sessionStroage放在客户端。`



##### 什么是Restful API

* 一种新的API设计方法

  * 传统API设计：把每一个url当作一个功能  

  * Reatful API设计：**把每个 url 当作一个唯一的资源标识**

    > 传统：/api/list?pageIndex=2
    >
    > Restful API：/api/list/2

    传统：

    > post请求：/api/create-blog
    >
    > post请求：/api/update-blog?id=100
    >
    > get请求：/api/get-blog?id=100

    Restful API

    > post请求：/api/blog
    >
    > post请求：/api/blog/100
    >
    > get请求：/api/blog/100

* 如何设计成一个资源

  * 尽量不用url参数
  * 用method表示操作类型

  > 通过向服务器提交的请求类型来表示增删改查这些操作
  >
  > get：请求资源
  >
  > post：新建资源
  >
  > put：修改资源（更新资源）/ patch ：修改资源
  >
  > delete：删除资源

##### http 缓存机制

[墙缓存、协商缓存](https://www.cnblogs.com/chengxs/p/10396066.html)

> 浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下：
>
> 1. http 缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在 respone header 头中回传资源的缓存参数；
> 2. 第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200。服务器并不会返回资源信息，浏览器继续从缓存加载资源；
> 3. 否则就把请求参数加到 request header 头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。

[缓存介绍----掘金](https://juejin.cn/post/6914271764012859406)

[缓存介绍----掘金](https://juejin.cn/post/6932115786601332749)

web缓存可大致分为：数据库缓存、服务器缓存、浏览器缓存；

浏览器缓存由分为：HTTP缓存、indexDB、localstoreage、cookie、pwa等。

* 浏览器缓存流程

* 强缓存

  > 浏览器第一次向服务器访问资源，服务器会返回资源并且在 Response Headers 中加入Cache-Control（max-age、no-cache、no-store、private、public）。
  >
  > 浏览器再次请求，浏览器判断这些请求参数，命中强缓存就直接200。

* 协商缓存

  > 浏览器第一次向服务器访问资源，服务器会返回资源和资源标识；再次请求时，带着资源标识，服务器判断是否命中协商缓存，返回304（命中）或者返回资源和新的资源标识。
  >
  > 资源标识：在Response Header 中，有两种，Last-Modified（资源的最后修改时间）、Etag资源的唯一标识（一个字符串，表示唯一）

##### 网页渲染

* 从输入 url 到渲染网页的整个过程

  > [掘金](https://juejin.cn/post/6844903989159411726)
  >
  > [掘金](https://juejin.cn/post/6844903815091748872)

#### 前端性能优化

[掘金性能优化](https://juejin.cn/post/6844903639115366408)

多使用内存、缓存等其他方法

减少CPU计算量，减少网络加载耗时

空间换时间

##### 1、限制事件处理函数频繁调用

[相关文档----掘金](https://juejin.cn/post/6914186870687694855)

1. 函数防抖

   防抖：**任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。**

   例子：有个输入框,输入之后会调用接口,获取联想词。但是,因为频繁调用接口不太好,所以我们在代码中使用防抖功能,只有在用户输入完毕的一段时间后,才会调用接口,出现联想词。

   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
     <meta http-equiv="X-UA-Compatible" content="ie=edge">
     <title>防抖</title>
   </head>
   <body>
     <button id="debounce">点我防抖！</button>
   
     <script>
       window.onload = function() {
         // 1、获取这个按钮，并绑定事件
         var myDebounce = document.getElementById("debounce");
         myDebounce.addEventListener("click", debounce(sayDebounce));
       }
   
       // 2、防抖功能函数，接受传参
       function debounce(fn) {
         // 4、创建一个标记用来存放定时器的返回值
         let timeout = null;
         return function() {	// 节流函数 / 真正的事件回调函数，this 是发生事件的标签
           // 5、每次当用户点击/输入的时候，把前一个定时器清除
           clearTimeout(timeout);
           // 6、然后创建一个新的 setTimeout，
           // 这样就能保证点击按钮后的 interval 间隔内
           // 如果用户还点击了的话，就不会执行 fn 函数
           timeout = setTimeout(() => {
             fn.call(this, arguments);
           }, 1000);
         };
       }
   
       // 3、需要进行防抖的事件处理
       function sayDebounce() {
         // ... 有些需要防抖的工作，在这里执行
         console.log("防抖成功！");
       }
   
     </script>
   </body>
   </html>
   ```

   

2. 函数节流：

   节流：**指定时间间隔内只会执行一次任务。**

   例子：1、懒加载要监听计算滚动条的位置,使用节流按一定时间的频率获取。

   ​			2、用户点击提交按钮,假设我们知道接口大致的返回时间的情况下,我们使用节流,只允许一定时间内点击一次。

   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
     <meta http-equiv="X-UA-Compatible" content="ie=edge">
     <title>节流</title>
   </head>
   <body>
   
     <button id="throttle">点我节流！</button>
   
     <script>
       window.onload = function() {
         // 1、获取按钮，绑定点击事件
         var myThrottle = document.getElementById("throttle");
         myThrottle.addEventListener("click", throttle(sayThrottle));
       }
   
       // 2、节流函数体
       function throttle(fn) {
         // 4、通过闭包保存一个标记
         let canRun = true;
         return function() {
           // 5、在函数开头判断标志是否为 true，不为 true 则中断函数
           if(!canRun) {
             return;
           }
           // 6、将 canRun 设置为 false，防止执行之前再被执行
           canRun = false;
           // 7、定时器
           setTimeout( () => {
             fn.call(this, arguments);
             // 8、执行完事件（比如调用完接口）之后，重新将这个标志设置为 true
             canRun = true;
           }, 1000);
         };
       }
   
       // 3、需要节流的事件
       function sayThrottle() {
         console.log("节流成功！");
       }
   
     </script>
   </body>
   </html>
   ```

   

## 计算机网络

##### 常见的状态码

* 1xx	服务器收到请求
* 2xx    请求成功
  * 200成功
* 3xx    重定向
  * 301永久重定向（配合location，浏览器自动处理）
  * 302临时重定向（配合location，浏览器自动处理）
  * 304资源未被修改
* 4xx    客户端错误
  * 403没有权限
  * 404资源未找到
* 5xx    服务端错误
  * 500服务器错误
  * 504网关超时

关于 301(永久重定向) 和 302(临时重定向) 区别：

>  我们之前网站的域名是 a.com，现在替换成了 b.com。但是用户并不知道域名改了，所以还是在浏览器里输入 a.com，Web服务器（apache 或者 ngnix）在收到请求后，在响应中包含：
>
>  - 状态码 301 及 b.com。用户的浏览器在收到响应后，**自动将输入栏网址改变为 b.com。**
>  - 或者状态码 302 及 b.com。用户的浏览器在收到响应后，**输入栏仍是显示旧网址，**但是显示的是 b.com的内容。

1. 301 和 302 区别

   301 是永久重定向，302是一种临时重定向。302表示被访问的资源暂时不能被访问。301表示被访问的资源被永久的删除了，搜索引擎在抓取的时候，会将新的url地址替换成老的url地址，可以在返回的响应的 location 首部去获取到返回的地址。比如，访问http://www.baidu..com 会自动跳转到https://www.baidu.com。

2. http 请求方式（get/ post / put/delete)



##### http常见的 header 有哪些？

* genaral headers

  > Cache-Control——控制缓存的行为； [详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)
  > Connection——决定当前的事务完成后，是否会关闭网络连接； [详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection)
  > Date——创建报文的日期时间； [详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Date)
  > Keep-Alive——用来设置超时时长和最大请求数；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Keep-Alive)
  > Via——代理服务器的相关信息；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Via)
  > Warning——错误通知；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Warning)
  > Trailer——允许发送方在分块发送的消息后面添加额外的元信息； [详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Trailer)
  > Transfer-Encoding——指定报文主体的传输编码方式；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Transfer-Encoding)
  > Upgrade——升级为其他协议；

* 常见的Request Headers

  > Accept——客户端可以处理的内容类型；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept)
  > Accept-Charset——客户端可以处理的字符集类型；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Charset)
  > Accept-Encoding——客户端能够理解的内容编码方式；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Encoding)
  > Accept-Language——客户端可以理解的自然语言；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language)
  > Authorization——Web 认证信息；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Authorization)
  > Cookie——通过Set-Cookie设置的值；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie)
  > DNT——表明用户对于网站追踪的偏好；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/DNT)
  > From——用户的电子邮箱地址；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/From)
  > Host——请求资源所在服务器；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Host)
  > If-Match——比较实体标记（ETag）；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Match)
  > If-Modified-Since——比较资源的更新时间；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since)
  > If-None-Match——比较实体标记（与 If-Match 相反）；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match)
  > If-Range——资源未更新时发送实体 Byte 的范围请求；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Range)
  > If-Unmodified-Since——比较资源的更新时间（与 If-Modified-Since 相反）；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since)
  > Origin——表明了请求来自于哪个站点；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin)
  > Proxy-Authorization——代理服务器要求客户端的认证信息；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Proxy-Authorization)
  > Range——实体的字节范围请求；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Range)
  > Referer——对请求中 URI 的原始获取方；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer)
  > TE——指定用户代理希望使用的传输编码类型；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/TE)
  > Upgrade-Insecure-Requests——表示客户端优先选择加密及带有身份验证的响应；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Upgrade-Insecure-Requests)
  > User-Agent——浏览器信息；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/User-Agent)

* 常见的Response Headers

  > Accept-Ranges——是否接受字节范围请求；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Ranges)
  > Age——消息对象在缓存代理中存贮的时长，以秒为单位；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Age)
  > Clear-Site-Data——表示清除当前请求网站有关的浏览器数据（cookie，存储，缓存）；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Clear-Site-Data)
  > Content-Security-Policy——允许站点管理者在指定的页面控制用户代理的资源；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy__by_cnvoid)
  > Content-Security-Policy-Report-Only—— [详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy-Report-Only)
  > ETag——资源的匹配信息；[链接描述](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag)
  > Location——令客户端重定向至指定 URI；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Location)
  > Proxy-Authenticate——代理服务器对客户端的认证信息；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Proxy-Authenticate)
  > Public-Key-Pins——包含该Web 服务器用来进行加密的 public key （公钥）信息；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Public-Key-Pins)
  > Public-Key-Pins-Report-Only——设置在公钥固定不匹配时，发送错误信息到report-uri；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Public-Key-Pins-Report-Only)
  > Referrer-Policy——用来监管哪些访问来源信息——会在 Referer 中发送；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy)
  > Server——HTTP 服务器的安装信息；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Server)
  > Set-Cookie——服务器端向客户端发送 cookie；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie)
  > Strict-Transport-Security——它告诉浏览器只能通过HTTPS访问当前资源；[详情](https://developer.mozilla.org/zh-CN/docs/Security/HTTP_Strict_Transport_Security)
  > Timing-Allow-Origin——用于指定特定站点，以允许其访问Resource Timing API提供的相关信息；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Timing-Allow-Origin)
  > Tk——显示了对相应请求的跟踪情况；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Tk)
  > Vary——服务器缓存的管理信息；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary)
  > WWW-Authenticate——定义了使用何种验证方式去获取对资源的连接；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/WWW-Authenticate)
  > X-XSS-Protection——当检测到跨站脚本攻击 (XSS)时，浏览器将停止加载页面；[详情](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-XSS-Protection)

* 自定义headers

##### http 和 https 的区别

http是超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。

HTTPS是一种**通过计算机网络**进行**安全通信**的传输协议，基于HTTP协议进行通信，利用**SSL/TLS建立安全信道**，加密数据包。HTTPS使用的主要目的是提供对**网站服务器**的**身份认证**，同时保护**交换数据**的**隐私与完整性**。

http

> 1. 无状态：议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作
>
> 2. 无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。
>
> 3. 简单、快速、灵活
>
> 4. 通信使用明文，请求和响应不会对通信方进行确认、无法保护数据的完整性

https

> 1. 内容加密：采用混合加密技术，中间者无法直接查看明文内容
> 2. 验证身份：通过证书认证客户端访问的是自己的服务器
> 3. 保护数据完整性：防止传输的内容被中间人冒充或者篡改

> http 和 https 区别
>
> * HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费
>
> * HTTP 是运行在 TCP 协议之上的，是明文传输，安全性较；HTTPS 是运行在 SSL / TLS层之上，通过 SSL \ TLS 进行了加密，安全性很高
>
> * HTTP 的端口号是 80，HTTPS 是 443

![](D:\Document\00_Notes\99面试笔记\media\SSL协议1.jpg)

![](D:\Document\00_Notes\99面试笔记\media\SSL协议2.jpg)

https 加密过程

![](D:\Document\00_Notes\99面试笔记\media\https加密过程.jpg)



> 对称加密算法加密数据 + 非对称加密算法交换密钥 + 数字证书验证身份 = 安全

HTTPS 在**内容传输**的加密上使用的是**对称加密**，非对称加密只作用在证书验证阶段。

1. 为什么数据传输是用对称加密？

   >  非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的。

2. HTTPS 的传输过程是怎样的？

   >  客户端发起 HTTPS 请求，服务端返回证书，客户端对证书进行验证，验证通过后本地生成用于改造对称加密算法的随机数，通过证书中的公钥对随机数进行加密传输到服务端，服务端接收后通过私钥解密得到随机数，之后的数据交互通过对称加密算法进行加解密。

> - 对称加密: 加密和解密的秘钥使用的是同一个.
>   - 优点：算法公开、计算量小、加密速度快、加密效率高
>   - 缺点：在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。
> - 非对称加密: 与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。
>   *  公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。
>   *  优点：安全
>   *  缺点：速度较慢

3. 使用 CA 证书的原因？

> 在第一次握手的过程中，中间人完全可以截获服务端发送给客户端的公钥，并且将自己的公钥发送给客户端。客户端用中间人的公钥加密对称密钥，再将结果发送给服务端，中间人再次截获，用自己的私钥解密，获取密钥，再用服务端的公钥加密后发送给服务端。这样，中间人分别冒出服务端和客户端跟彼此交互，就可以窃取信息了。
>
> 

##### 计算机网络各层协议

1. 物理层（Physical Layer）:OSI模型的最低层或第一层，规定了激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性，为上层协议提供了一个**传输数据的物理媒体**。

2. 数据链路层（Datalink Layer）:OSI模型的第二层，它控制网络层与物理层之间的通信，其主要功能是在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。

3. 网络层（Network Layer）:OSI模型的第三层，其主要功能是将**网络地址翻译成对应的物理地址**，并决定如何将数据从发送方路由到接收方。该层的作用包括：对子网间的数据包进行路由选择，实现拥塞控制、网际互连等功能。

4. 传输层（Transport Layer）:OSI模型中最重要的一层，是第一个**端到端，即主机到主机**的层次。其主要功能是负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。

5. 会话层（Session Layer）:OSI模型的第五层，管理**主机之间的会话进程**，即负责建立、管理、终止进程之间的会话。其主要功能是建立通信链接，保持会话过程通信链接的畅通，利用在数据中插入校验点来同步两个结点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。

6. 表示层（Presentation Layer）:OSI模型的第六层，应用程序和网络之间的翻译官，负责对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括**数据的解密和加密、压缩、格式转换**等。

7. 应用层（Application Layer）:OSI模型的第七层，负责为**操作系统或网络应用程序提供访问网络服务的接口**。术语“应用层”并不是指运行在网络上的某个特别应用程序，应用层提供的服务包括文件传输、文件管理以及电子邮件的信息处理。

   

##### tcp 三次握手和四次挥手

> 三次握手：为了确认**对方**的**发送和接收**能力。

> 三次握手主要流程：
>
> 从最开始双方都处于`CLOSED`状态。然后服务端开始监听某个端口，进入了`LISTEN`状态。
>
> 然后客户端主动发起连接，发送 SYN , 自己变成了`SYN-SENT`状态。
>
> 服务端接收到，返回`SYN`和`ACK`(对应客户端发来的SYN)，自己变成了`SYN-REVD`。
>
> 之后客户端再发送`ACK`给服务端，自己变成了`ESTABLISHED`状态；服务端收到`ACK`之后，也变成了`ESTABLISHED`状态。

> 为什么需要三次握手呢？为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。
>
> client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段，但是server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求，于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了，由于client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据，但server却以为新的运输连接已经建立，并一直等待client发来数据。所以没有采用“三次握手”，这种情况下server的很多资源就白白浪费掉了。



> 四次挥手
>
> 发送后客户端变成了`FIN-WAIT-1`状态。注意, 这时候客户端同时也变成了`half-close(半关闭)`状态，即无法向服务端发送报文，只能接收。
>
> 服务端接收后向客户端确认，变成了`CLOSED-WAIT`状态。
>
> 客户端接收到了服务端的确认，变成了`FIN-WAIT2`状态。
>
> 随后，服务端向客户端发送`FIN`，自己进入`LAST-ACK`状态，
>
> 客户端收到服务端发来的`FIN`后，自己变成了`TIME-WAIT`状态，然后发送 ACK 给服务端。

>  为什么是四次而不是三次？
>
>  如果是三次的话，那么服务端的 ACK 和 FIN 合成一个挥手，那么长时间的延迟可能让 TCP 一位 FIN 没有达到服务器端，然后让客户的不断的重发 FIN。
>
>  为什么需要四次挥手呢？TCP是全双工模式，当client发出FIN报文段时，只是表示client已经没有数据要发送了，client告诉server，它的数据已经全部发送完毕了；但是，这个时候client还是可以接受来server的数据；当server返回ACK报文段时，表示它已经知道client没有数据发送了，但是server还是可以发送数据到client的；当server也发送了FIN报文段时，这个时候就表示server也没有数据要发送了，就会告诉client，我也没有数据要发送了，如果收到client确认报文段，之后彼此就会愉快的中断这次TCP连接。

> 注意了，这个时候，客户端需要等待足够长的时间，具体来说，是 2 个 `MSL`(`Maximum Segment Lifetime，报文最大生存时间`), 在这段时间内如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。
>
> ### 等待2MSL的意义
>
> - 1 个 MSL 确保四次挥手中**主动关闭方**最后的 ACK 报文最终能达到对端
> - 1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达



##### 流量控制和拥塞控制

流量控制（由接收方控制发送发的速度）

* 数据链路层：停止等待协议、滑动窗口协议（单帧滑动窗口 1-1、多帧滑动窗口-后退N帧协议n-1、多帧滑动窗口-选择重传协议n-n）
* 传输层：TCP流量控制 min（接收窗口，拥塞窗口）

拥塞控制（让网络承受住现有的网络负荷（全局性））

* 慢开始和拥塞避免
  * 指数规律增大-->遇到阈值后；加法增大--> 网络拥塞； 乘法减小
* 快重传和快恢复
  * 接收方收到三个冗余 ACK ，即快重传，不用等报文段设置的重传计时器超时
  * 乘法减小时，从拥塞窗口的一般开始

##### HTTP1和HTTP2的区别

[CSDN](https://blog.csdn.net/JAVA_I_want/article/details/104648129)

>  Http1.0

1. 浏览器与服务器只保持短暂的连接，**浏览器的每次请求都需要与服务器建立一个TCP连接**（TCP连接的新建成本很高，因为需要客户端和服务器三次握手），**服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求**；

> Http1.1

1. 持久连接（**与Http1其它版本的最大区别**）引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive(对于同一个域名，大多数浏览器允许同时建立6个持久连接)

2. 虽然**允许复用TCP连接**，但是同一个TCP连接里面，所有的数据通信是**按次序进行的**。服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着。这将导致“队头堵塞”

>  Http/2.0

1. 采用**二进制格式**而非文本格式；HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”：头信息帧和数据帧。**二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少。**

2. **单一长连接**的完全**多路复用**，而非有序并阻塞的、只需一个连接即可实现并行；（**解决了线头阻塞的问题，与Http1最重要的区别**）

3. 使用**报头压缩**，降低开销

   > HTTP 协议是没有状态，导致每次请求都必须附上所有信息。所以，请求的很多头字段都是重复的，比如Cookie，一样的内容每次请求都必须附带，这会浪费很多带宽，也影响速度。
   > 对于相同的头部，不必再通过请求发送，只需发送一次；
   > HTTP/2 对这一点做了优化，引入了头信息压缩机制；
   > 一方面，头信息使用gzip或compress压缩后再发送；
   > 另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，产生一个索引号，之后就不发送同样字段了，只需发送索引号。

##### TCP 和 UDP 区别

1. TCP 是面向连接的，在传送数据之前必须先建立连接，数据传送结束后要释放连接。

   UDP 是无连接的，UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。

2. TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达；

   UDP 使用尽最大努力交付，不保证可靠交付

3. TCP 提供全双工通信， 面向字节流。

   UDP 是面向报文的

4. TCP 可以进行流量控制（滑动窗口）和拥塞控制（慢开始和拥塞避免、快重传和快恢复）；

   UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；



## 面试

##### 1、foreach filter map reduce 

```js
var arr = [3, 5, 34, 8, 23, 5]

/* 
    forEach()
    它总是返回 undefined 值，并且不可链式调用
    除了抛出异常以外，没有办法中止或跳出 forEach() 循环。
*/

var newArr1 = arr.forEach((value, i) => {
    // value += 1 // [ 3, 5, 34, 8, 23, 5 ]
    arr[i] += 1;
})

console.log(arr) // [ 4, 6, 35, 9, 24, 6 ]
console.log(newArr1) // undefined
```

```js
/**
    map()
    会返回一个新数组，如果没有返回语句，那么默认返回 undefined
 */

var newArr2 = arr.map((value, i) => {
    // value += 1 // [ 3, 5, 34, 8, 23, 5 ]
    arr[i] += 1;
})

console.log(arr) // [ 4, 6, 35, 9, 24, 6 ]
console.log(newArr2) // [ undefined, undefined, undefined, undefined, undefined, undefined ]
```

```js
/**
    fileter()
    返回符合条件的元素
 */

var newArr3 = arr.filter((value, i) => {
    arr[i] += 1      
    // value += 1   // [ 3, 5, 34, 8, 23, 5 ]
    return i % 2 == 0
})

console.log(arr)	// [ 4, 6, 35, 9, 24, 6 ]
console.log(newArr3) // [ 3, 34, 23 ]
```



1. map：创建一个新数组，返回该数组中每个元素调用一次提供的函数后的返回值；

2. filter：过滤中通过指定函数测试的元素；

3. reduce：这是一个数组的归并方法,对给定的数组进行遍历，函数的第一个参数是迭代计算后结果。

   ```js
   array.reduce(function(accumulator, currentValue, currentIndex, arr), initialValue)
   // 如果没有提供initValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引,total的默认值为数组的第一个元素。如果提供initValue，从索引0开始。
   // `initialValue`：传递给函数的初始值；
   ```

   * 数组求和

   ```js
   // 和为 6
   var total = [ 0, 1, 2, 3 ].reduce(( acc, cur ) => acc + cur,0);
   ```

   * 对象求和

   ```js
   // logs 6
   var initialValue = 0;
   var sum = [{x: 1}, {x:2}, {x:3}].reduce(function (accumulator, currentValue) {
       return accumulator + currentValue.x;
   },initialValue)
   
   console.log(sum)
   ```

   * 二维数组转成一维数组

   ```js
   var flattened = [[0, 1], [2, 3], [4, 5]].reduce(
     function(a, b) {
       return a.concat(b);
     },
     []);
   // flattened is [0, 1, 2, 3, 4, 5]
   ```

   

**例子：**

```js
var arr = [1, 3, 6, 9, 15, 19, 16];

// 1、产生一个每个元素都比原来大10的新数组
var newArr1 = arr.map((val, index) => val + 10)

// 2、得到所有奇数的和
var newArr2 = arr.reduce((acc, curr) => acc + (curr % 2 === 1 ? curr : 0), 0)

// 3、得到值大于8且下标是偶数的元素组成的数组
var newArr3 = arr.filter((val, index) => (index % 2 === 0) && val > 8)

// 4、找出一个值大于8且下标是偶数位的数(注意：是一个)
var newArr4 = arr.find((val, index) => val > 8 && (index % 2 === 0));

// 5、找出一个值大于8且下标是偶数位的数的下标(注意：是一个)
var index = arr.findIndex((val, index) => val > 8 && (index % 2 === 0));
```

4. every
5. some

```js
// every()是对数组中每一项运行给定函数,如果该函数对每一项返回true,则返回true。
// some()是对数组中每一项运行给定函数,如果该函数对任一项返回true,则返回true。
var arr = [ 1, 2, 3, 4, 5, 6 ]; 

console.log( arr.every( function( item, index, array ){ 
    console.log( 'item=' + item + ',index='+index+',array='+array ); 
    return item > 3; 
}));
/*
item=1,index=0,array=1,2,3,4,5,6
false
*/

console.log( arr.some( function( item, index, array ){ 
    console.log( 'item=' + item + ',index='+index+',array='+array ); 
    return item > 3; 
})); 
/*
item=1,index=0,array=1,2,3,4,5,6
item=2,index=1,array=1,2,3,4,5,6
item=3,index=2,array=1,2,3,4,5,6
item=4,index=3,array=1,2,3,4,5,6
true
*/
```



##### 2、手写深拷贝 与 for in

* for in 和 for of

> for...in 语句用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。
>  **for in得到对对象的key或数组,字符串的下标
>  for of和forEach一样,是直接得到值
>  for of不能对象用**

for in (以及forEach for) 是常规的同步遍历

```js
for(let i in this.book) {
	this.book[i]
}
```

for of 常用于异步的遍历

```js
for(let book of this.book) {
    
}
```

```js
function deepClone(obj = {}) {
    if (typeof obj !== 'object' || typeof obj == null) {
        // obj 是 null 类型，或者不是对象也不是数组（即简单数据类型）
        return obj;
    }
    let result
    if (obj instanceof Array) {
        // 是数组
        result = []
    } else {
        // 不是数组
        result = {}
    }
    // 上面也可以使用三元表达式去表示
    // result = obj instanceof Array ? [] : {}

    for (const key in obj) {
        // 保证 key 不是原型链的属性
        if (obj.hasOwnProperty(key)) {
            // 递归
            result[key] = deepClone(obj[key])
        }
    }

    return result
}
```



##### 3、求嵌套对象深度

##### 4、this、call、apply、bind区别

> **this 永远指向最后调用它的那个对象**
>
> **箭头函数的 this 始终指向函数定义时的 this，而非执行时。**“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。
>
> call：所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。
>
> apply语法：**fun.apply(thisArg, [argsArray])**
>
> ​			apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。
>
> bind 是创建一个新的函数，我们必须要手动去调用。
>
> 注意：`某个函数的参数是明确知道数量时用 call ; 而不确定的时候用 apply，然后把参数 push进数组传递进去`。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来遍历所有的参数

##### 5、浏览器渲染流程

[掘金](https://juejin.cn/post/6844903815091748872)

##### 6、一次完整的HTTP服务过程

1. 域名解析，得到 ip 地址
2. 根据 ip 地址，找到对应的服务器，发起 TCP 三次握手
3. 简历 TCP 连接后发起 HTTP 请求
4. 服务器相应 HTTP 请求，浏览器得到 HTML 代码
5. 浏览器解析 HTML 代码
6. 浏览器对页面进行渲染
7. 四次挥手，服务器关闭连接

* DNS 是怎么找到域名的？

  > - 当客户端需要域名解析时，通过本机的DNS客户端构造一个`DNS请求报文`，以`UDP数据报`方式发往`本地域名服务器`。
  > - 域名解析有两种方式:`递归查询`和`递归与迭代`相结合的查询。
  > - 依次是：本地域名服务器、根域名服务器、顶级域名服务器、权限域名服务器
  >
  > (1) 递归方式查询：先查询本地域名服务器，找不到后，本地域名服务器向根域名服务器查询，根域名服务器向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询。
  >
  > (2) 迭代方式查询：先查询本地域名服务器，找不到后，**本地域名服务器**向根域名服务器查询，**本地域名服务器**向顶级域名服务器查询，**本地域名服务器**向权限域名服务器查询。
  >
  > [CSDN-域名解析](https://blog.csdn.net/liuchang19950703/article/details/111507464)

* 三次握手和四次挥手

##### 7、script标签属性

1. 常用的就是src属性，通过指向一个外部地址来加载脚本，如果用了src属性，那么标签中的内容会被忽略，不会被执行的！！！

2. script标签是没有跨域问题，可以加载任何网站的脚本，和img标签非常类似，所以通常也会用来解决跨域问题，就是人们通常所说的JSONP。

3. charset表示字符集，是可选的参数，默认utf-8编码。type是内容类型，是可选的参数，默认是text/javascript。 这两个属性了解即可。

4. 默认script标签都是同步加载脚本的，因为脚本之间存在依赖关系，只要前面的执行完毕才能执行后面的代码。但是如果脚本之间没有必然的关系，那么一般会选择异步加载脚本来提高效率，需要使用async属性。

   > async要和src属性配合使用。因为只对外部脚本起作用，如果你是在script标签里面书写脚本，该脚本是不会异步加载！！！

5. 还有一个是defer属性，表示延迟执行，具体意思是当页面解析和显示之后再执行。这个属性也是针对外部属性才起作用。



>  async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）
>
>  ```
>  （1）脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执
>    行。
>  
>  （2）defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。
>    当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。
>  
>  （3）async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执
>    行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。
>  ```



##### 8、什么是重绘和回流？（浏览器绘制过程）

```
重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background
       -color，我们将这样的操作称为重绘。
 
 回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样
      的操作我们称为回流。

 常见引起回流属性和方法：

 任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。

 （1）添加或者删除可见的 DOM 元素；
 （2）元素尺寸改变——边距、填充、边框、宽度和高度
 （3）内容变化，比如用户在 input 框中输入文字
 （4）浏览器窗口尺寸改变——resize事件发生时
 （5）计算 offsetWidth 和 offsetHeight 属性
 （6）设置 style 属性的值
 （7）当你修改网页的默认字体时。

 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列
 回流。
```



##### 9、浏览器内核

##### 10、http1.1 和 http1.0 之间有哪些区别？

```
http1.1 相对于 http1.0 有这样几个区别：
（1）连接方面的区别，http1.1 默认使用持久连接，而 http1.0 默认使用非持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。
（2）资源请求方面的区别，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

（3）缓存方面的区别，在 http1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。

（4）http1.1 中还新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，就可以将请求发往同一台服务器上的不同网站。

（5）http1.1 相对于 http1.0 还新增了很多方法，如 PUT、HEAD、OPTIONS 等。
```

[http1、http2](https://blog.csdn.net/JAVA_I_want/article/details/104648129)





##### 11、箭头函数与普通函数区别：

> 1. 没有 this

**箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。**这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this。



> 2. 没有 arguments

箭头函数没有自己的 arguments 对象，这不一定是件坏事，因为箭头函数可以访问外围函数的 arguments 对象：

```js
function constant() {
    return () => arguments[0]
}

var result = constant(1);
console.log(result()); // 1
```



> 3. 不能通过 new 关键字调用

JavaScript 函数有两个内部方法：[[Call]] 和 [[Construct]]。

当通过 new 调用函数时，执行 [[Construct]] 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。

当直接调用的时候，执行 [[Call]] 方法，直接执行函数体。

箭头函数并没有 [[Construct]] 方法，不能被用作构造函数，如果通过 new 的方式调用，会报错。

```js
var Foo = () => {};
var foo = new Foo(); // TypeError: Foo is not a constructor
```



> 4. 没有 new.target

因为不能使用 new 调用，所以也没有 new.target 值。

关于 new.target，可以参考 [es6.ruanyifeng.com/#docs/class…](http://es6.ruanyifeng.com/#docs/class#new-target-属性)



> 5. 没有原型

由于不能使用 new 调用箭头函数，所以也没有构建原型的需求，于是箭头函数也不存在 prototype 这个属性。

```js
var Foo = () => {};
console.log(Foo.prototype); // undefined
```



> 6. 没有 super

连原型都没有，自然也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的，不过跟 this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。



##### 12、addEventListener和onclick的区别

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <ul id="color-list">
        <li id="addEvent">red</li>
        <li id="on_click">yellow</li>
    </ul>
    <script type="text/javascript">
        (function() {
            var addEvent = document.getElementById("addEvent");
            addEvent.addEventListener("click", function() {
                alert("我是addEvent1");
            }, false);
            addEvent.addEventListener("click", function() {
                alert("我是addEvent2");
            }, false);

            var addEvent = document.getElementById("on_click");

            on_click.onclick = function() {
                alert("我是click1");
            }
            on_click.onclick = function() {
                alert("我是click2");
            }
        })();
    </script>
</body>

</html>
```

> 点击第一个，两个事件都会触发
>
> 点击第二个，之后最后一个才会有效。



##### 13、currentTarget VS target

1. target：触发事件的元素。
   currentTarget：事件绑定的元素。
2. 两者在没有冒泡的情况下，是一样的值，但在用了事件委托的情况下，就不一样了；
3. currentTarget始终是监听事件者，而target是事件的真正发出者。



##### 14、继承

1. 构造函数继承（call&apply）

> 说明：直接利用call或者apply方法将父类构造函数的this绑定为子类构造函数的this就可以；
> 缺点：无法继承原型链上的属性与方法；

2. 原型继承

> 说明：将子类的原型挂载到父类上；
> 缺点：子类new出来的实例，父类的属性没有隔离，会相互影响；

3. 组合继承

> 说明：组合上面的构造函数与原型继承的功能；
> 缺点：call()方法已经拿到父类所有的属性 ，后面再使用原型时也会有父类所有属性；

4. 寄生组合继承

> 说明：解决组合继承重复属性的问题，直接将子类的原型等于父类的原型，或者是用Object.create继承原型但不执行父类构造函数；
> 注意处理子类实例的 constructor 指向问题，new Parent2()也有这个问题；

5.  Class继承

> 说明：ES6新增，class是一个语法糖，就是基于寄生组合继承来实现的；

 

##### 15、手写数组去重

```js
var arr = [1, 3, 5, 2, 4, 2, 1, 5, 8]

function fn(arr) {
    let set = new Set(arr);
    return [...set];
}

function del(arr) {
    let result = [];
    for (let i = 0; i < arr.length; i++) {
        if (result.indexOf(arr[i]) == -1) {
            result.push(arr[i]);
        }
    }
    return result;
}

console.log(del(arr))		// [ 1, 3, 5, 2, 4, 8 ]
console.log(fn(arr))		// [ 1, 3, 5, 2, 4, 8 ]
```

##### 16、数组扁平化

```js
/* ES6 */
const flatten = (arr) => {
  let result = [];
  arr.forEach((item, i, arr) => {
    if (Array.isArray(item)) {
      result = result.concat(flatten(item));
    } else {
      result.push(arr[i])
    }
  })
  return result;
};

const arr = [1, [2, [3, 4]]];
console.log(flatten(arr));

// 自己定义
function flatFn(arr) {
    let res = []
    arr.forEach(value => {
        if (Array.isArray(value)) {
            res = res.concat(flatFn(value))
        } else {
            res.push(value)
        }
    })
    return res
}
```



## 前端安全

### 一、xss: 跨站脚本攻击（Cross Site Scripting)

> 在网页中恶意注入代码，使用户加载执行。

目的可能有：

1. 获取当前用户在这个网站上的cookies， 从而拿到用户的敏感性息。
2. 以用户的身份发起一些非用户本人本意的操作请求，比如删除好友，发私信等。
3. 实现DDos攻击。

根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。

#### 1、DOM 型 XSS

DOM 型 XSS 的攻击步骤：

1. 攻击者**构造出特殊的 URL，其中包含恶意代码**。
2. 用户打开带有恶意代码的 URL。
3. 用户浏览器接收到响应后解析执行，**前端 JavaScript 取出 URL 中的恶意代码并执行**。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

>  DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。



#### 2、反射型 XSS

反射型 XSS 的攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL 时，**网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器**。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

>  反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。
>
>  反射型 XSS 漏洞常见于通过 URL **传递参数的功能，如网站搜索、跳转**等。
>
>  由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。
>
>  POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。



#### 3、存储型 XSS

存储型 XSS 的攻击步骤：

1. 攻击者将**恶意代码提交到目标网站的数据库**中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

> 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。



#### 防御手段

1. 使用`HTML`转义，对所有外部插入的代码都做一次转义，`script`，`& < > " ' /` 等危险 字符做过滤和专题替换，避免使用`innerHTML`、`document.write`等方法，使用安全性较高的`textContent `、`setAttribute`等方法代替。

2. 开启csp方法。在HTTP响应头中设置Content-Security-Policy:

   ```json
   Content-Security-Policy: scrippt-src `self`
   ```

   > 禁止加载外域代码，防止复杂的攻击逻辑。
   >
   > 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。
   >
   > 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。
   >
   > 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。
   >
   > 合理使用上报可以及时发现 XSS，利于尽快修复问题。
   >
   > 

#### 思考

1. XSS 防范是后端 RD 的责任，后端 RD 应该在所有用户提交数据的接口，对敏感字符进行转义，才能进行下一步操作。

> 不正确。因为：
>
> - 防范存储型和反射型 XSS 是后端 RD 的责任。而 DOM 型 XSS 攻击不发生在后端，是前端 RD 的责任。防范 XSS 是需要后端 RD 和前端 RD 共同参与的系统工程。
> - 转义应该在输出 HTML 时进行，而不是在提交用户输入时。

1. 所有要插入到页面上的数据，都要通过一个敏感字符过滤函数的转义，过滤掉通用的敏感字符后，就可以插入到页面中。

> 不正确。 不同的上下文，如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等，所需要的转义规则不一致。 业务 RD 需要选取合适的转义库，并针对不同的上下文调用不同的转义规则。



### 二、csrf：跨站点请求伪造（Cross-Site Request Forgeries)

原理图

![](D:\Document\00_Notes\面试笔记\media\csrf攻击.jpg)



CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。



一个典型的CSRF攻击有着如下的流程：

- [受害者登录a.com](http://xn--a-f38al5vkzdt61bv7l.com)，并保留了登录凭证（Cookie）。
- [攻击者引诱受害者访问了b.com](http://xn--b-nv6ao4io8bp6po6e00mu47cda4311avpa330h.com)。
- [b.com](http://b.com) 向 [a.com](http://a.com) 发送了一个请求：[a.com/act=xx。浏览器会…](http://a.com/act=xx。浏览器会默认携带a.com的Cookie。)
- a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
- a.com以受害者的名义执行了act=xx。
- 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。



#### 防御手段

1. 设置 cookie 的 sameSite 属性。它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie。

   **Samesite=Strict**

   `Strict`最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。

   

   **Samesite=Lax**

   `Lax`规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。

   导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。

   | 请求类型  |                 示例                 |    正常情况 | Lax         |
   | :-------- | :----------------------------------: | ----------: | :---------- |
   | 链接      |         `<a href="..."></a>`         | 发送 Cookie | 发送 Cookie |
   | 预加载    | `<link rel="prerender" href="..."/>` | 发送 Cookie | 发送 Cookie |
   | GET 表单  |  `<form method="GET" action="...">`  | 发送 Cookie | 发送 Cookie |
   | POST 表单 | `<form method="POST" action="...">`  | 发送 Cookie | 不发送      |
   | iframe    |    `<iframe src="..."></iframe>`     | 发送 Cookie | 不发送      |
   | AJAX      |            `$.get("...")`            | 发送 Cookie | 不发送      |
   | Image     |          `<img src="...">`           | 发送 Cookie | 不发送      |

   **Samesite=None**

   Chrome 计划将`Lax`变为默认设置。这时，网站可以选择显式关闭`SameSite`属性，将其设为`None`。不过，前提是必须同时设置`Secure`属性（Cookie 只能通过 HTTPS 协议发送），否则无效。

   下面的设置无效。

   > ```bash
   > Set-Cookie: widget_session=abc123; SameSite=None
   > ```

   下面的设置有效。

   > ```bash
   > Set-Cookie: widget_session=abc123; SameSite=None; Secure
   > ```

2. CSRF Token

   服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了，否则又会被攻击者冒用。因此，存放在**Local / session storage** 中，每次请求的时候都要带上，服务器需要判断Token的有效性。

3. 服务端判断请求头中的Referer 和Origin ，判断请求来源。

4. 手机验证码、邮箱验证等二次验证。

## vue常见面试题

##### 1、对 MVVM 的理解？

软件架构设计模式

```
传统的 MVC 指的是,用户操作会请求服务端路由，路由会调用对应的控制器来处理,控制器会获取数据。将结果返回给前端,页面重新渲染。
MVVM :传统的前端会将数据手动渲染到页面上,MVVM模式不需要用户手动操作dom元素，将数据绑定到 viewModel 层上，会自动将数据渲染到页面中，视图变化会通知 viemodel 层更新数据。viemodel 就是我们MVVM模式中的桥梁。
```

> Model层仅仅关注数据本身，这里可以把它理解为一个类似json的数据对象。View层通过使用模板语法来声明式的将数据渲染进DOM。ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中
>
> 在 MVVM 中，不需要手动地同步View和Model，View 是通过数据驱动的，Model一旦改变就会相应的刷新对应的 View，View 如果改变，也会改变对应的Model。这种方式就可以在业务处理中只**关心数据的流转**，而无需直接和页面打交道。
>
> 在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。



##### 2、vue2.x 的响应式数据原理？

[Vue响应式系统技术原理和Vue3响应式系统的优点](https://juejin.cn/post/6844904021619113992#heading-0)



观察者模式、依赖收集、派发更新

**1、observe 函数和 defineReactive 函数**

目的：把**目标对象属性**转换成**访问器属性**

> observer 函数

首先new了一个依赖收集器，这个dep的作用是，当目标对象增删属性时，通知对目标对象“感兴趣”的观察者；

最后遍历对象属性，并执行defineReactive函数。

> defineReactive函数

创建了一个dep实例，这个dep 在访问器属性的 getter/setter 中被闭包引用，这个dep的作用是当目标对象属性发生写操作时，通知“感兴趣”的观察者

如果属性是对象或者数组，则调用observe函数并把这个属性当做实参，目的是使目标对象深度可侦测；

使用Object.defineProperty函数把目标对象属性转成访问器属性，在getter方法里，通过执行dep.depend方法，收集对当前属性“感兴趣”的观察者；在setter方法里，执行observe(newVal)，把新增加的属性值变成可侦测的，并执行dep.notify()，通知对此属性“感兴趣”的所有观察者。



**对对象属性进行增删操作的拦截**

Object.defineProperty并不能拦截对象增删属性，Vue是通过Vue.set和Vue.delete实现对象增删属性拦截的。set方法里，首先将新加的属性设置为访问器属性，使其变为响应式，然后调用target.__ob__.dep.notify方法，通知观察者。del方法里，首先将属性从对象里删除，然后调用target.__ob__.dep.notify方法，通知观察者。



**对数组操作的拦截**

数组的侦测，首先重写数组的原型为arrayMethods；然后遍历数组，对每一个元素调用observe函数。何为arrayMethods？首先设置arrayMethods的原型为Array.prototype；然后往arrayMethods上定义7个属性，这7个属性其实是重写的7个数组变异方法。有的数组变异方法是可以新增元素的，要把新增加的元素变成响应式的；在所有的变异方法里都会调用数组的__ob__.dep.notify方法通知观察者。



**Vue2可以拦截的数据变更：**

* 对象属性的写操作；

* 非根级响应式对象的增删属性操作；

* 数组7个变异方法的拦截。

  

 **Vue2不能拦截的数据变更：**

* Vue 不允许动态添加**根级响应式属性**，所以你必须在初始化实例前声明所有根级响应式属性；

* 使用array[index] = item方式给**数组元素赋值**；

* 使用array.length = newLength方式**改变数组长度**。



##### 3、Vue3相比Vue2在响应式系统方面的提升

* Vue3的数据劫持是通过Proxy实现的，而Vue2是通过Object.defineProperty实现的
* Vue3支持Object、Array、Map、WeakMap、Set、WeakSet六种数据类型的数据劫持，而Vue2只支持Object、Array两种数据类型；并且Vue3可以劫持对象的属性增删和数组的索引操作。
  

##### 4、Object.defineProperty 和 proxy 对比

1、`Object.defineProperty`无法监听数组变化。`vm.items[indexOfItem] = newValue`这种是无法检测的。

2、`Object.defineProperty`的第二个缺陷,只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。



1、我们可以看到,Proxy直接可以劫持整个对象,并返回一个新对象,不管是操作便利程度还是底层功能上都远强于`Object.defineProperty`。

2、Proxy可以直接监听数组的变化

3、Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是`Object.defineProperty`不具备的。

4、Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而`Object.defineProperty`只能遍历对象属性直接修改。



##### 5、vue里面为什么要进行异步渲染

Vue 异步执行 DOM 更新。只要**观察到数据变化**，Vue 将**开启一个队列**，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。

现在有这样的一种情况，mounted的时候test的值会被++循环执行1000次。 每次++时，都会根据响应式触发`setter->Dep->Watcher->update->run`。 如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。 所以Vue实现了一个`queue`队列，在下一个Tick（或者是当前Tick的微任务阶段）的时候会统一执行`queue`中`Watcher`的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。 保证更新视图操作DOM的动作是在当前栈执行完以后下一个Tick（或者是当前Tick的微任务阶段）的时候调用，大大优化了性能。



##### 6、vue中computer和watch之间有什么区别？

**computed是计算属性**，事实上和和data对象里的数据属性是同一类的（使用上）。

1. **支持缓存**，只有依赖数据发生改变，才会重新进行计算
2. **不支持异步**，当computed内有异步操作时无效，无法监听数据的变化
3. computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过的数据通过计算得到的
4. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed
5. 如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。

**watch是侦听属性**

1. **不支持缓存**，数据变，直接会触发相应的操作；
2. **watch支持异步**；
3. 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；
4. 当一个属性发生变化时，需要执行对应的操作；一对多；



##### 7、生命周期

##### 8、v-if v-show

1.`v-if`在条件切换时，会对标签进行适当的创建和销毁，而`v-show`则仅在初始化时加载一次，因此`v-if`的开销相对来说会比`v-show`大。
 2.`v-if`是惰性的，只有当条件为真时才会真正渲染标签；如果初始条件不为真，则`v-if`不会去渲染标签。`v-show`则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的CSS切换。



##### 9、v-for 和 v-if 不能连用的原因？

v-for 会比 v-if优**先执行**，当一个标签上面同时存在：`v-for` 和 `v-if` 的时候，会先执行v-for循环，

然后去看循环出来的每个div上面flag的值，是真还是假。如果flag为true，就显示 ，否则就不显示

这样就造成了不必要的`性能浪费`



##### 10、为什么使用v-for时必须添加唯一的key?

使用`v-for`更新已渲染的元素列表时,默认用`就地复用`策略

​		列表数据修改的时候,他会根据key值去判断某个值是否修改,如果修改,则重新渲染这一项,否则复用之前的元素; 我们在使用的使用经常会使用`index`(即数组的下标)来作为`key`,但其实这是**不推荐**的一种使用方法；key的作用主要是为了高效的更新虚拟DOM。



##### 11、$nextTick用过吗，有什么作用？

​		在下次 DOM 更新循环结束之后 执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。(官网解释)
 解决的问题：有些时候在改变数据后立即要对dom进行操作，此时获取到的dom仍是获取到的是数据刷新前的dom，无法满足需要，这个时候就用到了$nextTick。

```JS
Vue.component('example', {
  template: '<span>{{ message }}</span>',
  data: function () {
    return {
      message: '未更新'
    }
  },
  methods: {
    updateMessage: function () {
      this.message = '已更新'
      console.log(this.$el.textContent) // => '未更新'
      this.$nextTick(function () {
        console.log(this.$el.textContent) // => '已更新'
      })
    }
  }
})
```



##### 为什么要在mutations 里面更改数据状态？

因为state是实时更新的，mutations无法进行异步操作，而如果直接修改state的话是能够异步操作的，当你异步对state进行操作时，还没执行完，这时候如果state已经在其他地方被修改了，这样就会导致程序存在问题了。所以state要同步操作，通过mutations的方式限制了不允许异步。

##### 为什么 mutations 是同步的？

##### 组件中的data 为什么是一个函数？

一个组件被复用多次的话，也就会创建多个实例。本质上，**这些实例用的都是同一个构造函数**。如果data是对象的话，对象属于**引用类型**，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。

watch

eventBus

## 常见的排序算法及其时间复杂度

### 1、快排

### 2、堆排序

### 3、归并排序

### 4、冒泡排序





## 常用API

字符串和数组的互相转化

```
1、数组中 toString() 方法能够把每个元素转换为字符串，然后以逗号连接输出显示。

var a = [1,2,3,4,5,6,7,8,9,0];  //定义数组
var s = a.toString();  //把数组转换为字符串
console.log(s);  //返回字符串“1,2,3,4,5,6,7,8,9,0”
console.log(typeof s);  //返回字符串string，说明是字符串类型

join() 方法可以把数组转换为字符串，不过它可以指定分隔符。在调用 join() 方法时，可以传递一个参数作为分隔符来连接每个元素。如果省略参数，默认使用逗号作为分隔符，这时与 toString() 方法转换操作效果相同。
var a = [1,2,3,4,5];  //定义数组
var s = a.join("==");  //指定分隔符
console.log(s);  //返回字符串“1==2==3==4==5”

下面使用 split() 方法把字符串转换为数组。
split() 方法是 String 对象方法，与 join() 方法操作正好相反。该方法可以指定两个参数，第 1 个参数为分隔符，指定从哪儿进行分隔的标记；第 2 个参数指定要返回数组的长度。
var s = "1==2== 3==4 ==5";
var a = s.split("==");
console.log(a);
console.log(a.constructor == Array);
```

JS 的除法和 Java 是不一样的

可以使用 Math.floor 来向下取整，达到一样的效果

```JS
var a = 123
var b = a / 10
var c = a % 10

console.log(b)              //12.3
console.log(Math.floor(b))  // 12
console.log(c)              // 3
```

